{"pages":[{"title":"About","text":"Gallery Netease","link":"/about/index.html"}],"posts":[{"title":"2 IELTS Reading Tips Which Will Get You Band 8","text":"来源：2 IELTS Reading Tips Which Will Get You Band 8 Getting Band 8 in IELTS reading is a difficult task but not impossible. For achieving 8 Band, you must concentrate a lot and have a prior sound strategy in your mind that could be implemented well on the day of your IELTS exam. If you are giving IELTS Academic exam, you must score 35 out of 40 to achieve Band 8 score which means you can afford to do hardly 5 mistakes in your exam. On the other hand, you must score 37 out of 40 for achieving a band score of 8 in IELTS General Training which implies you can only make 3 mistakes in your exam. IELTS candidates who were successful in receiving Band 9 have given some extremely useful tips that can help you get high band score in IELTS reading. Let us discuss what these top secrets of Band 8 are: Solving Questions Simultaneously While Reading PassageThe foremost thing that you as an IELTS candidate must be aware of is that you get your answers from the passage in the order of questions. For example, answer to question 1 in paragraph 2, answer to question 2 in paragraph 4 and so on. In this example case, you would never get answer to question 2 before the statement in paragraph 2 where you had received answer for question 1. For this reason, you can adopt an excellent strategy that works really well in IELTS reading and which is nothing but solving the questions side by side while you are reading the passage. For instance, first read question 1 and then start reading the passage to find its answer. Once you get answer for this question, go to question 2 and again start reading the passage from where you had stopped. In this manner, you would not be required to waste your time in reading the whole passage and you would be quickly finding out answers in no time. By doing this, you would never complain to be out of time while solving the questions in IELTS reading exam. Marking Answers in the Reading PassageOne of the effective strategies given by a candidate, who appeared in IELTS exam and received Band 9, is that you can mark answers in your reading passage rather than writing them first on the question paper and then transferring in your sheet which would consume double the time unnecessarily. Not only minutes but even seconds can be costly enough for losing out a particular question. Hence if you save some time, you are able to devote that saved time in solving a new question. Now, you cannot mark answers in reading passage for all the questions. Short answers, summary completion, flow chart, diagram labelling, fill-ups etc. are the questions where you can use this strategy. Basically, the questions where you are to write words, you can mark them in the passage itself and then transfer these answers quickly after you solve one passage rather than first writing the answers alongside the question and then transferring in your answer sheet. This will certainly save your time and help you get good score in IELTS reading.","link":"/2022/08/26/2-IELTS-Reading-Tips-Which-Will-Get-You-Band-8/"},{"title":"Climbing Stairs","text":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 12345Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 123456Input: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 来源：力扣（LeetCode） 超时解法：无脑递归1234567891011public class climbStairs { public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; return climbStairs(n - 1) + climbStairs(n - 2); } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：$O(2^n)$ （每层递归的complexity是上一层的2倍）空间复杂度：$O(n)$ （递归层数） 为什么这里空间复杂度是O(n)? 递归的空间复杂度是：递归的深度*每次递归所需的辅助空间的个数 辅助空间指的是为局部变量和形参所开辟的空间，对于递归算法，由于运行时有附加堆栈，所以递归的空间复杂度是递归的深度*每次压栈所需的空间个数。 递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数递归最深的那一次所耗费的空间足以容纳它所有递归过程。（递归是要返回上一层的，所以它所需要的空间不是一直累加起来的） 所以最深的那次压栈就是递归的空间复杂度。递归的深度是n，而每次递归所需的辅助空间个数为1。 由上图可知，很多节点重复求解多次，所以可以使用HashMap来保存求解过程中已经求过的值。 HashMap12345678910111213141516171819202122import java.util.HashMap;import java.util.Map;public class climbStairs { private static Map&lt;Integer, Integer&gt; storeMap = new HashMap&lt;&gt;(); public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; if (storeMap.get(n) != null) { return storeMap.get(n); } else { int result = climbStairs(n - 1) + climbStairs(n - 2); storeMap.put(n, result); return result; } } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：O(n) （链表）空间复杂度：O(n) （存储桶，链表） JDK1.8之前，HashMap底层实现用的是数组+链表，HashMap通过hash计算key的哈希值，然后hash%n（n为数组长度，初始化数组默认长度为16），得到key在数组中存放的下标；当出现哈希冲突时（两个key在数组中存放的下标一致），数据以链表形式存储；在链表中查找数据必须从第一个元素开始一层一层地往下找，直到找到为止，时间复杂度为O(n)，所以当链表长度越来越长时，HashMap的效率越来越低。 JDK1.8之后，corporate into了红黑树，当链表中的元素超过8（TREEIFY_THRESHOLD），并且数组长度大于64（MIN_TREEIFY_CAPACITY）时，会将链表转换为红黑树，转换之后数据查询的时间复杂度从O(n)降至O(logn)。 递归转循环12345678910111213public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int result = 0; int pre = 2; int prePre = 1; for (int i = 3; i &lt;= n; ++i) { result = pre + prePre; prePre = pre; pre = result; } return result;} 时间复杂度：O(n)空间复杂度：O(1) （辅助空间是常数级别的）","link":"/2022/08/20/Climbing-Stairs/"},{"title":"Decode String","text":"给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像&nbsp;3a&nbsp;或&nbsp;2[4]&nbsp;的输入。 12输入：s = \"3[a]2[bc]\"输出：\"aaabcbc\" 来源：力扣（LeetCode） StringBuilder12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class StringDecoding { public static String decodeString(String s) { StringBuilder res = new StringBuilder(); int multi = 0; Stack&lt;Integer&gt; stack_multi = new Stack&lt;Integer&gt;(); Stack&lt;String&gt; stack_res = new Stack&lt;String&gt;(); for (Character c : s.toCharArray()) { if (c == '[') { stack_multi.push(multi); stack_res.push(res.toString()); multi = 0; res = new StringBuilder(); } else if (c == ']') { StringBuilder tmp = new StringBuilder(); int cur_multi = stack_multi.pop(); for (int i = 0; i &lt; cur_multi; i++) { tmp.append(res); } res = new StringBuilder(stack_res.pop() + tmp); } else if (c &gt;= '0' &amp;&amp; c &lt;= '9') { multi = multi * 10 + c - '0'; } else res.append(c); } return res.toString(); } public static void main(String[] args) { String s = \"3[a]2[bc]\"; System.out.println(decodeString(s)); }} String、StringBuffer与StringBuilder String StringBuffer StringBuilder String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。也由于它的不可变性，类似拼接、裁剪字符串等动作，每次对String的操作都会生成新的 String对象。 为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，减小了开销，是绝大部分情况下进行字符串拼接的首选。 StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 参考：https://www.joshua317.com/article/241 StringBuilder和String可以相互转换 String-&gt;StringBuilder：可以使用StringBuilder的构造方法，StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder-&gt;String：可以使用StringBuilder中的toString方法。public String toString() 将当前StringBuilder对象转换为String对象。 Integer.parseInt(String s)具有参数类型String，而不是number.charAt(i)返回的char。 转换为String： 1a.add(Integer.parseInt(\"\" + number.charAt(i)));","link":"/2022/08/17/Decode-String/"},{"title":"Garbage Collection","text":"来源：Garbage Collection in Java Automatic Garbage Collection - Java automatically allocates and deallocates memory so programs are not burdened with that task. Garbage Collection in JavaGarbage collection in Java is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine, or JVM for short. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory. What is Garbage Collection?In C/C++, a programmer is responsible for both the creation and destruction of objects. Usually, programmer neglects the destruction of useless objects. Due to this negligence, at a certain point, sufficient memory may not be available to create new objects, and the entire program will terminate abnormally, causing OutOfMemoryErrors. But in Java, the programmer need not care for all those objects which are no longer in use. Garbage collector destroys these objects. The main objective of Garbage Collector is to free heap memory by destroying unreachable objects. The garbage collector is the best example of the Daemon thread as it is always running in the background. How Does Garbage Collection in Java works?Java garbage collection is an automatic process. Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in-use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused or unreferenced object is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed. The programmer does not need to mark objects to be deleted explicitly. The garbage collection implementation lives in the JVM. Types of Activities in Java Garbage CollectionTwo types of garbage collection activity usually happen in Java. These are: Minor or incremental Garbage Collection: It is said to have occurred when unreachable objects in the young generation heap memory are removed. Major or Full Garbage Collection: It is said to have occurred when the objects that survived the minor garbage collection are copied into the old generation or permanent generation heap memory are removed. When compared to the young generation, garbage collection happens less frequently in the old generation. Important Concepts Related to Garbage Collection in JavaUnreachable objects:An object is said to be unreachable if it doesn’t contain any reference to it. Also, note that objects which are part of the island of isolation are also unreachable. 1234Integer i = new Integer(4);// the new Integer object is reachable via the reference in 'i' i = null;// the Integer object is no longer reachable. Eligibility for garbage collection:An object is said to be eligible for GC(garbage collection) if it is unreachable. After i = null, integer object 4 in the heap area is suitable for garbage collection in the above image. Ways to make an object eligible for Garbage Collector Even though the programmer is not responsible for destroying useless objects but it is highly recommended to make an object unreachable(thus eligible for GC) if it is no longer required. There are generally four ways to make an object eligible for garbage collection. Nullifying the reference variable Re-assigning the reference variable An object created inside the method Island of Isolation Ways for requesting JVM to run Garbage Collector Once we make an object eligible for garbage collection, it may not destroy immediately by the garbage collector. Whenever JVM runs the Garbage Collector program, then only the object will be destroyed. But when JVM runs Garbage Collector, we can not expect. We can also request JVM to run Garbage Collector. There are two ways to do it : Using System.gc() method: System class contain static method gc() for requesting JVM to run Garbage Collector. Using Runtime.getRuntime().gc() method: Runtime class allows the application to interface with the JVM in which the application is running. Hence by using its gc() method, we can request JVM to run Garbage Collector. There is no guarantee that any of the above two methods will run Garbage Collector. The call System.gc() is effectively equivalent to the call : Runtime.getRuntime().gc() Finalization Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object. finalize() method is present in Object class with the following prototype. 1protected void finalize() throws Throwable Based on our requirement, we can override finalize() method for performing our cleanup activities like closing connection from the database. The finalize() method is called by Garbage Collector, not JVM. However, Garbage Collector is one of the modules of JVM. Object class finalize() method has an empty implementation. Thus, it is recommended to override the finalize() method to dispose of system resources or perform other cleanups. The finalize() method is never invoked more than once for any object. If an uncaught exception is thrown by the finalize() method, the exception is ignored, and the finalization of that object terminates. Advantages of Garbage Collection in JavaThe advantages of Garbage Collection in Java are: It makes java memory-efficient because the garbage collector removes the unreferenced objects from heap memory. It is automatically done by the garbage collector(a part of JVM), so we don’t need extra effort. Real-World ExampleLet’s take a real-life example, where we use the concept of the garbage collector. Question: Suppose you go for the internship at GeeksForGeeks, and you were told to write a program to count the number of employees working in the company(excluding interns). To make this program, you have to use the concept of a garbage collector. Write a program to create a class called Employee having the following data members. An ID for storing unique id allocated to every employee. Name of employee. age of an employee. Also, provide the following methods: A parameterized constructor to initialize name and age. The ID should be initialized in this constructor. A method show() to display ID, name, and age. A method showNextId() to display the ID of the next employee. Tuning GuideGarbage Collector Implementation Now any beginner, who doesn’t know Garbage Collector in Java will code like this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Java Program to count number// of employees working// in a company class Employee { private int ID; private String name; private int age; private static int nextId = 1; // it is made static because it // is keep common among all and // shared by all objects public Employee(String name, int age) { this.name = name; this.age = age; this.ID = nextId++; } public void show() { System.out.println(\"Id=\" + ID + \"\\nName=\" + name + \"\\nAge=\" + age); } public void showNextId() { System.out.println(\"Next employee id will be=\" + nextId); }} class UseEmployee { public static void main(String[] args) { Employee E = new Employee(\"GFG1\", 56); Employee F = new Employee(\"GFG2\", 45); Employee G = new Employee(\"GFG3\", 25); E.show(); F.show(); G.show(); E.showNextId(); F.showNextId(); G.showNextId(); { // It is sub block to keep // all those interns. Employee X = new Employee(\"GFG4\", 23); Employee Y = new Employee(\"GFG5\", 21); X.show(); Y.show(); X.showNextId(); Y.showNextId(); } // After countering this brace, X and Y // will be removed.Therefore, // now it should show nextId as 4. // Output of this line E.showNextId(); // should be 4 but it will give 6 as output. }} output123456789101112131415161718192021Id=1Name=GFG1Age=56Id=2Name=GFG2Age=45Id=3Name=GFG3Age=25Next employee id will be=4Next employee id will be=4Next employee id will be=4Id=4Name=GFG4Age=23Id=5Name=GFG5Age=21Next employee id will be=6Next employee id will be=6Next employee id will be=6 Now to get the correct output: Now garbage collector(gc) will see 2 objects free. Now to decrement nextId,gc(garbage collector) will call method to finalize() only when we programmers have overridden it in our class. And as mentioned previously, we have to request gc(garbage collector), and for this, we have to write the following 3 steps before closing brace of sub-block. Set references to null(i.e X = Y = null;) Call, System.gc(); Call, System.runFinalization(); Now the correct code for counting the number of employees(excluding interns) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Correct code to count number// of employees excluding interns. class Employee { private int ID; private String name; private int age; private static int nextId = 1; // it is made static because it // is keep common among all and // shared by all objects public Employee(String name, int age) { this.name = name; this.age = age; this.ID = nextId++; } public void show() { System.out.println(\"Id=\" + ID + \"\\nName=\" + name + \"\\nAge=\" + age); } public void showNextId() { System.out.println(\"Next employee id will be=\" + nextId); } protected void finalize() { --nextId; // In this case, // gc will call finalize() // for 2 times for 2 objects. }} public class UseEmployee { public static void main(String[] args) { Employee E = new Employee(\"GFG1\", 56); Employee F = new Employee(\"GFG2\", 45); Employee G = new Employee(\"GFG3\", 25); E.show(); F.show(); G.show(); E.showNextId(); F.showNextId(); G.showNextId(); { // It is sub block to keep // all those interns. Employee X = new Employee(\"GFG4\", 23); Employee Y = new Employee(\"GFG5\", 21); X.show(); Y.show(); X.showNextId(); Y.showNextId(); X = Y = null; System.gc(); System.runFinalization(); } E.showNextId(); }} output123456789101112131415161718192021Id=1Name=GFG1Age=56Id=2Name=GFG2Age=45Id=3Name=GFG3Age=25Next employee id will be=4Next employee id will be=4Next employee id will be=4Id=4Name=GFG4Age=23Id=5Name=GFG5Age=21Next employee id will be=6Next employee id will be=6Next employee id will be=4","link":"/2022/08/30/Garbage%20Collection/"},{"title":"Designed to Last: 10 of the world's most ingenious building","text":"来源：Designed to Last: 10 of the world’s most ingenious buildings Why abandon buildings once they’re no longer needed? A new book reveals the best projects finding new uses for factories, grain silos and market halls. For BBC Culture’s new series Designed to Last, here are 10 of the most ingenious – and inspiring – spaces around the globe. “The shifts in how we live and work have radically altered our cities,” writes Ruth Lang in new Gestalten book Building for Change: The Architecture of Creative Reuse. “The spatial demands of working patterns have been utterly transformed over the past 50 years.” Many of our buildings could last for 50, or even 100, years; yet “fashion and changing patterns of use often curtail this lifespan, which sometime barely stretches to a decade”. Instead of abandoning these structures, however, designers are developing innovative solutions “which find value in the buildings that have been left behind… in place of our obsession with newness”. Building for Change explores how creative reuse could be the way forward for designing spaces around the world. While some architects are restoring and adapting existing buildings to meet new purposes, others are designing structures that can be readily repurposed for alternative uses further down the line. As Lang writes, “innovation doesn’t always have to mean creating anew – it can mean approaching existing resources in new ways”. Even within those parameters, ambitiously creative designs are still possible – ones “that push the limits of architectural imagination”. Here, 10 projects – including former factories, sugar mills, grain silos and market halls – reveal the most ingenious, imaginative responses to an increasingly urgent global challenge. Building for Change: The Architecture of Creative Reuse is out now. Baoshan WTE Exhibition Centre, Shanghai, China Kokaistudios A former steel mill in Shanghai has been turned into an eco-park that includes a new thermo-electric waste-to-energy power plant, wetlands, an exhibition centre and offices. One of the last remaining industrial structures in the city’s Luojing neighbourhood, the factory is a heritage site. Architects Kokaistudios kept its structure intact, fitting an independent modular system of panelling around the existing steel frame, “reimagining its rusting pipework and machinery as a design feature rather than a problem to be dealt with”, according to Building for Change. The polycarbonate screens are reusable and lightweight, which “enables the interior spaces to be flexible in configuration, reducing costs and construction times for adaptations as the site develops and the users’ needs change”. They also mean that the site’s appearance is transformed “from ‘darkly overbearing’ to ‘warmly welcoming’ – even at night, when the building glows from within”. Kibera Hamlets School, Nairobi, KenyaSelgasCano and Helloeverything Just as the modular structure of Baoshan means that it can be dismantled and removed for future reuse on an alternative site, a project in Denmark embedded a second life into its initial design. “In accepting the commission to create a temporary pavilion for the Louisiana Museum of Modern Art near Copenhagen, Madrid studio SelgasCano and New York’s Helloeverything pre-empted an afterlife for their creation”, according to Building for Change. “They designed a structure that would not only suit the purposes of the brief, but which could be deconstructed, transported, and relocated elsewhere.” The former exhibition pavilion now houses a school for 600 pupils in Kibera, one of the largest urban slums in Africa. Dutch photographer Iwan Baan suggested the project’s new incarnation, which provides educational facilities for nursery, primary and secondary pupils in 12 enclosed classrooms. Exploiting the universal modular scaffolding system, which can easily be transported and adapted, the structure was constructed over two months by the architects and 20 members of the Kibera neighbourhood. Alila Yangshuo Hotel, Guangxi, ChinaVector Architects Surrounded by ancient villages in an ecologically-protected setting, this abandoned 1960s sugar mill has been converted into a luxury hotel by Vector Architects. The landscape is as much a feature of the site as the buildings, and a structural truss – previously used for transferring sugar cane to the boats on the Li River below – has been stripped back to its functional concrete core, which now frames a newly-built pool. The original construction of the buildings has been mostly kept and simplified, with one wing of the hotel acting as a sound barrier to the highway that runs alongside the site. Zeitz Museum of Contemporary Art Africa, Cape Town, South AfricaHeatherwick Studio This 1920s grain silo on Cape Town’s Victoria &amp; Alfred Waterfront was the tallest building in sub-Saharan Africa until the mid-1970s – and has been decommissioned since 1990. “The agricultural structure is an emblem of South Africa’s colonial history as well as another chapter in its post-Apartheid future,” according to Building for Change. “Its transformation fractures these historic associations without denying them, to form what… is renowned as the world’s largest museum dedicated to contemporary African and diaspora art.” London’s Heatherwick Studio carved into eight of the 42 reinforced concrete tubes that made up the grain lift and storage annex, to form 80 galleries across six levels, as well as a huge void at the centre “within which the nature and complexity of these spaces can finally be appreciated”. Kamikatsu Zero Waste Centre, Kamikatsu, JapanHiroshi Nakamura &amp; NAP “In 2003, after the forced decommissioning of its waste incinerator, the municipality issued a Zero Waste Declaration requiring all waste produced by the area’s residents to be reused or recycled to reduce the demands for landfill or incineration,” according to Building for Change. “Rather than increase emissions by shipping waste to the nearest city for processing, a new centre was created where residents can separate and source materials for recycling and reuse.” To challenge public perceptions of a “waste centre”, the site includes a shop selling reclaimed items, a community hall, a laundry, a hotel and an educational space for research into ways of increasing reuse. The horseshoe-shaped plan allows easy access to materials, while the centre’s construction incorporated waste materials from local houses, schools and government buildings left derelict by the area’s depopulation – including 700 retrieved windows that form the walls of the structure, bolstered by plastic crates once used for mushroom harvesting. Local residents now recycle 80% of their waste, compared to a national average of 20%. Qinglongwu Capsule Hotel and Library, Jinhua, ChinaAtelier tao+c The 20 capsule bedrooms in this former barn are surrounded by bookcases made from locally-sourced bamboo, while the bathrooms sit in the roof space. Architects Atelier tao+c staggered the bedrooms throughout the building, interspersed with double-height spaces which add to the sense of lightness created by a suspended framework. The self-contained construction is separate from the building’s skin, and in places, the steel grid is concealed within the bookcases, which provide a sense of privacy. EOI Melilla Language School, Melilla, SpainÁngel Verdasco Arquitectos One of two autonomous Spanish cities located in North Africa, Melilla borders Morocco. When its central market building closed in 2003, it “created a rupture in the neighbourhood’s cohesion”, according to Building for Change, as the 90-year-old commercial centre was a “social catalyst, connecting the city’s Christian, Muslim, and Jewish communities”. Ángel Verdasco Arquitectos won a 2008 competition seeking a design that embodied the market’s social value, their proposal transforming the site into a music academy, a language school and an educational centre for adults – providing “cross-cultural connectivity” that offers Melilla’s different communities a place to interact. The original market walls were left freestanding, enclosing the structures within and building upon “the memories and identity of the market, which might otherwise have been swept away”. An aluminium lattice frame is a contemporary reinterpretation of local Islamic architecture, mirroring perforated jail screens that control light and ventilation through an interior space. Inside, the derelict market hall was stripped back to its skin, within which “a new structure that echoes the social purpose of the historic building has been constructed”, according to Building for Change. “The centre acts as a mediating space for the different communities and functions that occupy the site,” and fosters multiculturalism “by reappropriating the market structure for its new purpose”. Castle Acre Water Tower, Norfolk, UKTonkin Liu “Built in 1952, this water tower in Norfolk, England, wasn’t originally deemed worthy of saving by local authorities,” according to Building for Change. “Previously housed on an airfield, it was subsequently auctioned as scrap.” Luckily, it was rescued by new owners, who converted the tower into their home. By cutting a ribbon window, replacing one line of the panelled steel grid that forms the walls of the tank, the architects produced panoramic views of the surrounding landscape. A timber stair enclosure braces the tower, preventing the roof from shifting against the lower level in high winds, while a stair tower acts as a thermal chimney, creating ventilation when the windows are closed. Waste materials were reused, with the unit clad in recycled aluminium-plastic panels, and the stair tower’s balustrade was made from steel tie rods that were removed from the tank. Tai Kwun Centre for Heritage and Arts, Hong KongHerzog &amp; de Meuron “Built as a compound by the British after taking control of Hong Kong in 1841, the Central Police Station, Central Magistracy and Victoria Prison have all since been listed. Along with 16 other historic buildings, they occupy… ‘the largest heritage conservation project in Hong Kong’”, according to Building for Change. The buildings were so old that they had no construction records, meaning that engineers needed to do a forensic investigation in order to plan an appropriate method of repair. There were other challenges when creating the two new structures: minimising vibration during works to avoid damaging existing buildings, and using innovative ways of creating foundations because of the high density of the site, which is now a cultural and shopping centre. Lakeside Plugin Tower, Beijing, ChinaPeople’s Architecture Office A prototype demonstrating the benefits of modular construction, located in an area of protected farmland, Lakeside Plugin Tower is intended to touch the ground lightly – minimising disruption to the ecology, water table and wildlife of the site, and enabling easy removal to other sites in the future. “The modules are designed for ease of transport from the factory where they are prefabricated, and can be assembled without skilled labourers,” according to Building for Change. A large variety of shapes and potential configurations “allow for a more creative assembly, enabling users to angle units to take advantage of views, and to create different combinations of textures and colours with the panels”. That changes the role of the architect, who gives up control over layout, shape, size and colour. It also extends the building’s lifespan almost indefinitely. “The house’s plug-in structure is designed to be added to and adapted over time, as shifts in technology and the needs of its occupants dictate.”","link":"/2022/08/30/Designed-to-Last-10-of-the-world-s-most-ingenious-building/"},{"title":"How to Expand Your Vocabulary","text":"来源：How to Expand Your Vocabulary? Lexical resource is a very important marking criterion in IELTS writing and speaking which implies using a wide range of vocabulary accurately. Apart from this, vocabulary knowledge will also help you a lot in reading. Thus, it is one of the reasons why students worry a lot for learning new words which they can use while they speak or write. Also, that candidates who receive less than 5 band have limited vocabulary while 7 band and above use a wide range of vocabulary and hence, vocabulary is essential for IELTS preparation.Let us consider some of the tips for expanding vocabulary. Read NewspapersReading is the best habit to learn new words and it will also help you to improve your skills for IELTS reading module. You can subscribe a daily or weekly newspaper online or offline and have the habit of reading articles on a daily basis. While you read articles, do underline the words that you do not know or notice carefully if you come to know about the use of a word in a different way. Then, check the word meaning in your dictionary and write down in your notebook. Learn the noted words and do revise them once or twice a week. Useful Links: http://www.bbc.com/news/http://www.economist.com/ Keep a DictionaryA very common method of learning vocabulary is to keep a small pocket-sized dictionary with you. If you never devoted time to learn new words in this way, you can develop this habit now. There are two ways you can use your dictionary to learn words. Firstly, you can refer it any time you come across a new word and check its meaning in the dictionary. Secondly, you can start learning the words in sequence from first to the last page of your dictionary. In this way, you can at least become familiar to new words every day and depending upon how much time you devote per day, you may be able to read all the words in your dictionary in several days or months. However, for effective learning, keep in mind to learn a word whole-heartedly. If you feel you cannot understand a word, just skip it because learning a word incorrectly is even more dangerous. Learn vocabulary effectively in the following way: Check the word meaning (in English and/or in your native language) Learn its right pronunciation Learn its synonyms Use this word to form a sentence Practice more and more while speaking and writing For example: Perception meaning– Ability to see through perceptionSynonyms – Awareness, recognitionExample: Different people have different perception about beauty. Useful Link: http://www.enchantedlearning.com/Aisfor.shtmlhttp://www.oxfordlearnersdictionaries.com/wordlist/english/academic/http://dictionary.cambridge.org/browse/pronunciation/http://www.thesaurus.com/browse/perception (Search a keyword to know synonyms) Listen to Audios &amp; Watch VideosThe best way of learning the usage of a new word is when you listen to it being used by others. So, you can watch TV programmes, news channels, movies, YouTube videos, group discussions, talk shows etc. You can also listen to audios such as podcasts, songs, radio channels etc. One more thing is that you can prefer watching or listening to the stuff that you find interesting so that you may not get bored and stop your plan to learn vocabulary. The concept behind this method is that you are exposed to new words and hence, you learn faster in this way. When you watch videos or listen to some audios, pay more attention to the words and how they are used. Watching video stuff online is also a good idea where you can pause or replay the videos to learn at your own pace. You can start by listening to videos which have sub-titles. This will help you improve your comprehension as well as listening skills. In case, you come across a new word, use the dictionary to find the meaning and at least one synonym. Learn with FunNowadays, there are many games available on the websites and game applications can also be installed in mobile phones which can be some of the most interesting and exciting ways to learn vocabulary. This will definitely help those who find it boring to read books. Useful Links: http://eslgamesworld.com/members/games/levels/high/index.html Learn Idioms &amp; ConnectivesUse of idiomatic language and sentence connectors while you speak on a topic would be effective. In academic writing task 1, you should use connectives while idioms can be be avoided as they are used for informal writing. And hence, students appearing in IELTS General Training may use them while writing a letter. But make sure you use them when required and do not unnecessarily try to include them excessively. Useful Link: http://idioms.thefreedictionary.com/ Practice is the key!Practicing using the vocabulary is extremely important, otherwise you will forget a word even after noting it down. Target number of words to be learnt daily and revise them every week by practicing their use in writing and speaking. In this way, you are really going to improve your knowledge of new words and getting familiar with them. The more you practice, the more you can use them naturally as it is also essential that you don’t hesitate while using the newly learnt words.Lastly, while you learn words, you can also further ensure that you know the correct use in terms of spelling, punctuation, usage in a sentence and collocation (combination of words)","link":"/2022/08/16/How%20to%20Expand%20Your%20Vocabulary/"},{"title":"How to Finish 3 IELTS Reading Comprehension in Less Than 60 Mins","text":"来源：How to Finish 3 IELTS Reading Comprehension in Less Than 60 Mins? It is often a big hurdle faced by many IELTS students to struggle for completing the IELTS reading exam in 1 hour and finishing it in less than 1 hour is unimaginable for them. However, if proper strategy is implemented, it is definitely possible to complete the 3 IELTS reading comprehension passages in less than 60 minutes. Let us know the right strategies for the same. Solve Questions While Reading PassagesIf you had been running out of time while solving IELTS reading passages, one of the best strategies, which absolutely works as the most practical solution, is that you should solve your questions while you are reading the passage for the first time. Usually, students are advised the protocol of first reading the passage and then solving questions. Instead of this, it would be better to read the question first and then start reading the passage. Once you find answer of first question, read the second question and then again start reading the passage from when you had left. By following this strategy, you would never complain about not completing the reading passages on time. Rather you would find some time left to review your answers as well. Transfer Answers SimultaneouslyAnother important tip that you should keep in mind is that you must transfer your answers simultaneously since you do not get extra time for this in IELTS reading. For this strategy, you can do one thing. First, solve one passage and mark the answers on the question paper. Once you are done with solving that passage, immediately transfer those marked answers on the answer sheet. This would also give you confidence on completing a passage and to avoid last minute rush of writing down answers in the answer sheet. Apart from this, you can also save time by marking the words in the passages instead of writing them on the question paper and then transfer to answer sheet from the passage itself. Divide Your Time EffectivelyRemember that you have only 60 minutes to solve 40 questions which are divided into 3 passages. Last passage is definitely going to be difficult and hence, you may devote some more time there. Implementing the effective time strategies would help you a lot in IELTS reading test. You should try to solve your first passage in less than 20 minutes. Similarly, you should also do second passage in less than 20 minutes so that you have some more minutes to solve third passage. Do Not Spend More Time on a Single QuestionWhile solving IELTS reading passages by following the above strategies, you also need to make sure that you are not devoting extra time on a single question. It is, for sure, going to be the case that a few questions are very difficult and to solve them, you may need peace of mind. Instead of spending more and more time on such difficult questions, if you move on and solve the other simple questions, you would save time and gain confidence as well. Later on, you can solve the pending questions or simply guess them but do make sure that those difficult questions are marked well otherwise you may forget to solve them.","link":"/2022/08/15/How-to-Finish-3-IELTS-Reading-Comprehension-in-Less-Than-60-Mins/"},{"title":"Intersection of Two Linked Lists","text":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. 注意，函数返回结果后，链表必须保持其原始结构。 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 12345输入：intersectVal&nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 来源：力扣（LeetCode） 双指针：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class intersectLinkedList { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } public ListNode() { } } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } public static void main(String[] args) { ListNode node1 = new ListNode(4); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(8); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); ListNode node6 = new ListNode(1); ListNode node7 = new ListNode(6); ListNode node8 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node8.next = node7; node7.next = node6; node6.next = node3; System.out.print(getIntersectionNode(node1, node8).val); }} 两链表从同一位置开始遍历：128 1 6 3 2 70 8 1 6 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class intersectLinkedList { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } public ListNode() { } } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { int L1 = 0, L2 = 0, diff = 0; ListNode head1 = headA, head2 = headB; while (head1 != null) { L1++; head1 = head1.next; } while (head2 != null) { L2++; head2 = head2.next; } if (L1 &lt; L2) { head1 = headB; head2 = headA; diff = L2 - L1; } else { head1 = headA; head2 = headB; diff = L1 - L2; } for (int i = 0; i &lt; diff; i++) head1 = head1.next; while (head1 != null &amp;&amp; head2 != null) { if (head1 == head2) return head1; head1 = head1.next; head2 = head2.next; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(8); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(6); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(2); ListNode node6 = new ListNode(7); ListNode node7 = new ListNode(0); ListNode node8 = new ListNode(2); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = node6; node7.next = node1; node3.next = node8; System.out.print(getIntersectionNode(node1, node7).val); }}","link":"/2022/08/07/Intersection-of-Two-Linked-Lists/"},{"title":"IELTS Reading- Sentence Completion Tips and Strategy","text":"来源：IELTS Reading- Sentence Completion Tips and Strategy These questions are as much vocabulary tests as they are reading tests because they require you to be aware of paraphrasing (using different words to repeat a sentence so that it has the same meaning) and synonyms (words with the same or very similar meanings). Task descriptionIn this kind of question you will be given a number of sentences with gaps in them and asked to complete the sentences with words from the reading text. How to approach this task Read the incomplete sentences first. Think about what word form can be used and try to predict the answer. Also think about keywords and how they could be represented by synonyms or paraphrasing. Locate where the information is located by scanning quickly. If you can’t locate the answer quickly, move on. Read the incomplete sentence again. Study the reading text more carefully to establish the answer. ExampleChoose the correct letter, A, B, C or D. 1 When Willis Carrier invented air conditioning, his aim was to A make workers feel cooler. B produce more attractive paper. C set up a new business. D solve problems in a factory. 2 Home air conditioners were not popular at first because they were A too big and expensive. B not considered necessary. C too inefficient. D complicated to use. 3 Employers refused to put air conditioning in workplaces at first because they A could not afford to pay for it. B thought it was more suitable for cinemas. C did not want to spend money improving working conditions. D thought people would not work so hard in comfortable conditions. Link: http://mini-ielts.com/822/reading/air-conditioning How to solve this test? Find where the answer is located in the text before you try to answer the question. Remember where before what. Read the questions before reading the text. Keyword table for this practice test: Keywords in Questions Similar words in Passage When Willis Carrier invented air conditioning, his aim was to solve problems in a factory Carrier’s invention made it possible to control temperature and humidity levels and so align the colours. Home air conditioners were not popular at first because they were too big and expensive. However, its size, similar to that of an early computer, meant it took up too much space to come into widespread use, and later models, such as the Weathermaker, which Carrier brought out in the 1920s, cost too much for most people. Employers refused to put air conditioning in workplaces at first because they did not want to spend money improving working conditions. They considered that if they were paying people to work, they should not be paying for them to be comfortable as well. Explanation:Question 1: Find the keywords in the reading passage that has similar words in the question:control temperature and humidity levels = solve problems in a factory So answer of Q1 is D. Question 2: Find the keywords in the reading passage that has similar words in the question: it took up too much space = too big ; cost too much = expensive So answer of Q2 is A. Question 3: Find the keywords in the reading passage that has similar words in the question: paying = spend money ; comfortable = improving working conditions So answer of Q3 is C. Now continue this technique with another questions. This may seem like a lot of work and in the beginning but once you have practised this many times, you will be able to find your answers really fast and with much better accuracy and that will improve your score. You can practice more this type of question at: http://mini-ielts.com/reading?search=&amp;q11=on&amp;count=&amp;sort=date-desc","link":"/2022/08/13/IELTS-Reading-Sentence-Completion-Tips-and-Strategy/"},{"title":"Implement Queue using Stacks","text":"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：你只能使用标准的栈操作 —— 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 来源：力扣（LeetCode） 构造的时候要时刻记住此方法非彼方法，一个自己实现的queue方法，一个是stack类提供的方法 123IsEmpty:false3 1 2 IsEmpty:true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Stack;class MyQueue { Stack&lt;Integer&gt; stack1; Stack&lt;Integer&gt; stack2; /** * Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } /** * Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { if (!stack1.isEmpty()) { in2out(); } return stack2.pop(); } /** * Get the front element. */ public int peek() { if (!stack1.isEmpty()) { in2out(); } return stack2.peek(); } /** * Returns whether the queue is empty. */ public boolean empty() { if (!stack1.isEmpty()) { return stack1.isEmpty(); } else return stack2.isEmpty(); } public void in2out() { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } public static void main(String[] args) { MyQueue queue = new MyQueue(); queue.push(3); queue.push(1); queue.push(2); System.out.println(\"IsEmpty:\" + queue.empty()); while (!queue.empty()) { System.out.print(queue.peek() + \" \"); queue.pop(); } System.out.println(\"\\nIsEmpty:\" + queue.empty()); }} 看似没什么问题，然而 是不是push写错了？ 12345678910public void push(int x) { if (!stack2.isEmpty()) { while (!stack2.isEmpty()) { Integer pop = stack2.pop(); stack1.push(pop); } stack1.push(x); } else stack1.push(x);} 事实上，这个方法没写全，如果stack2为空，将stack1中的元素全部放到stack2中 12345public void in2out() { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } 1234567public void in2out() { if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } }","link":"/2022/08/10/Implement-Queue-using-Stacks/"},{"title":"Leetcode Binary-Tree","text":"来源：Binary-Tree 二叉树的中序遍历 (94)12输入：root = [1,null,2,3]输出：[1,3,2] 递归 1234567891011121314public static List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); inorder(root, res); return res;}public static void inorder(TreeNode root, List&lt;Integer&gt; res) { if (root == null) { return; } inorder(root.left, res); res.add(root.val); inorder(root.right, res);} 非递归：迭代 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }}class Solution { public static List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); res.add(root.val); root = root.right; } return res; } public static void main(String[] args) { TreeNode root = new TreeNode(1); TreeNode n1 = new TreeNode(2); TreeNode n2 = new TreeNode(3); root.right = n1; n1.left = n2; List&lt;Integer&gt; rs = inorderTraversal(root); System.out.println(rs); }}","link":"/2022/08/30/Leetcode%20Binary-Tree/"},{"title":"Linked List Cycle","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;next&nbsp;pointer. Internally, pos&nbsp;is used to denote the index of the node that&nbsp;tail’s&nbsp;next&nbsp;pointer is connected to.&nbsp;Note that&nbsp;pos&nbsp;is not passed as a parameter. Return&nbsp;true if there is a cycle in the linked list. Otherwise, return false. 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 来源：力扣（LeetCode） 快慢指针：跑的快的总能套圈12345678910111213141516171819202122232425262728293031323334353637public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slowPtr = head, fastPtr = head; while (fastPtr.next != null &amp;&amp; fastPtr.next.next != null) { slowPtr = slowPtr.next; fastPtr = fastPtr.next.next; if (slowPtr == fastPtr) return true; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中的节点数）空间复杂度：O(1) （只使用了两个指针的额外空间） 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 n 轮。 HashSet不重复的添加，添加元素时会判断是否已经存在,已经存在会添加不成功 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashSet;import java.util.Set;public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { Set seen = new HashSet(); while (head != null) { if (!seen.add(head)) return true; head = head.next;// if (seen.contains(head)) return true;// seen.add(head);// head = head.next; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中节点数）空间复杂度：O(n) （主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次） https://blog.csdn.net/weixin_45453739/article/details/122644349 Relevant Problem给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 不允许修改链表。 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 进阶：你是否可以使用 O(1) 空间解决此题？ 快慢指针： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static ListNode detectCycle(ListNode head) { if (head == null) return null; ListNode tortoise = head, rabbit = head; boolean loopExists = false; while (rabbit.next != null &amp;&amp; rabbit.next.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; if (tortoise == rabbit) { loopExists = true; break; } } if (loopExists == true) { tortoise = head; while (tortoise != rabbit) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(detectCycle(node1).val); }}","link":"/2022/08/05/Linked-List-Cycle/"},{"title":"Palindrome Linked List","text":"Given the head of a singly linked list, return true if it is a palindrome or false otherwise. 12Input: head = [1,2,2,1]Output: true 12Input: head = [1,2]Output: false 来源：力扣（LeetCode） 快慢指针+反转链表：中规中矩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PalindromeLinkedList { public static class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseNode(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static boolean isPalindrome(ListNode head) { ListNode tortoise = head, rabbit = head; while (rabbit != null &amp;&amp; rabbit.next != null) { rabbit = rabbit.next.next; tortoise = tortoise.next; } if (rabbit != null) tortoise = tortoise.next; //如果链表为奇数节点，慢指针指向下一个节点，把正中间节点让给左边 tortoise = reverseNode(tortoise); rabbit = head; while (tortoise != null) { if (tortoise.val != rabbit.val) return false; rabbit = rabbit.next; tortoise = tortoise.next; } return true; } public static void main(String[] args) { ListNode node4 = new ListNode(1, null); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); System.out.print(isPalindrome(node1)); }} 合一块 12345678910111213141516171819202122232425public static boolean isPalindrome(ListNode head) { if (head == null || head.next == null) { return true; } ListNode slow = head, fast = head; ListNode pre = null; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; ListNode temp = slow.next; slow.next = pre; pre = slow; slow = temp; } if (fast != null) { slow = slow.next; } while (pre != null &amp;&amp; slow != null) { if (pre.val != slow.val) { return false; } pre = pre.next; slow = slow.next; } return true;} Relevant Problem 1Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 来源：力扣（LeetCode） 123Input: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3. 123Input: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. 天然适配双指针： 123456789101112131415161718192021222324252627282930313233343536373839public class MiddleOfTheLinkedList { public static class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode middleNode(ListNode head) { ListNode tortoise = head, rabbit = head; while (rabbit != null &amp;&amp; rabbit.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; } return tortoise; } public static void main(String[] args) { ListNode node6 = new ListNode(6, null); ListNode node5 = new ListNode(5, node6); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); System.out.println(middleNode(node1).val); }} Relevant Problem 2剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 来源：力扣（LeetCode） 12给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 快慢指针：12345678910111213141516171819202122232425262728293031323334353637public class BottomK { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode getKthFromEnd(ListNode head, int k) { ListNode tortoise = head, rabbit = head; while (k-- != 0) { rabbit = rabbit.next; } while (rabbit != null) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(getKthFromEnd(node1, 2).val); }} 时间复杂度：O(n)空间复杂度：O(1) 距离表示另一种解决此题的思路是：对链表进行一次完整遍历，拿到总长度cnt，cnt-k即是倒数第k个节点与head节点之间的距离 1234567891011public static ListNode getKthFromEnd(ListNode head, int k) { int cnt = 0; ListNode tmp = head; while (tmp != null) { tmp = tmp.next; cnt++; } cnt = cnt - k; while (cnt-- != 0) head = head.next; return head;} 时间复杂度：O(n)空间复杂度：O(1) 栈/队列：一个使用额外空间的解法是利用栈（队列），将所有的节点压入占中栈（队列）中，令当前栈（队列）容量为 cnt。 然后从栈顶（队列头）弹出 k 个（cnt - k + 1个）元素，最后一个出栈（出队列）的元素即是答案。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayDeque;import java.util.Deque;public class BottomK { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode getKthFromEnd(ListNode head, int k) { Deque&lt;ListNode&gt; d = new ArrayDeque&lt;&gt;(); while (head != null) { d.addLast(head); head = head.next; } ListNode ans = null; while (k-- &gt; 0) ans = d.pollLast(); return ans; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(getKthFromEnd(node1, 2).val); }} 时间复杂度：O(n)空间复杂度：O(n)","link":"/2022/08/02/Palindrome-Linked-List/"},{"title":"Merge Two Sorted Lists","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 12Input: list1 = [1,2,4], list2 = [1,3,4]Output: [1,1,2,3,4,4] 12Input: list1 = [], list2 = []Output: [] 12Input: list1 = [], list2 = [0]Output: [0] 来源：力扣（LeetCode） 循环+双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class mergeTwoSortedLists { public static class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode resultNode = new ListNode(0); ListNode p = resultNode; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) p.next = list1; if (list2 != null) p.next = list2; return resultNode.next; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(2); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(4); ListNode node6 = new ListNode(4); node1.next = node3; node3.next = node5; node2.next = node4; node4.next = node6; ListNode node = mergeTwoLists(node1, node2); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n+m)空间复杂度：O(1) 递归12345678910public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val &lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } list2.next = mergeTwoLists(list1, list2.next); return list2;} 时间复杂度：O(n+m)空间复杂度：O(n+m)","link":"/2022/08/04/Merge%20Two%20Sorted%20Lists/"},{"title":"Remove Duplicates from Sorted List","text":"Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 12Input: head = [1,1,2]Output: [1,2] 12Input: head = [1,1,2,3,3]Output: [1,2,3] 来源：力扣（LeetCode） 遍历链表：如果next和当前重复了，就把next指向next的next，否则当前指向next。 1234567891011121314151617181920212223242526272829303132333435363738394041public class duplicateRemoval { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode deleteDuplicates(ListNode head) { if (head == null) { return head; } ListNode currentNode = head; while (currentNode != null &amp;&amp; currentNode.next != null) { if (currentNode.next.val == currentNode.val) { currentNode.next = currentNode.next.next; } else { currentNode = currentNode.next; } } return head; } public static void main(String[] args) { ListNode node5 = new ListNode(3, null); ListNode node4 = new ListNode(3, node5); ListNode node3 = new ListNode(2, node4); ListNode node2 = new ListNode(1, node3); ListNode node1 = new ListNode(1, node2); ListNode node = deleteDuplicates(node1); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n) （每一个节点都要检查一次确定是否重复）空间复杂度：O(1) （没有使用额外空间） 双指针：12345678910111213141516public static ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head; while (pre != null) { if (pre.val != cur.val) { cur.next = pre; cur = cur.next; } pre = pre.next; } cur.next = null; return head;} 递归：1234567public static ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head;} 时间复杂度：O(n)","link":"/2022/07/31/Remove-Duplicates-from-Sorted-List/"},{"title":"Reverse Linked List","text":"Given the head of a singly linked list, reverse the list, and return the reversed list. 12Input: head = [1,2,3,4,5]Output: [5,4,3,2,1] 来源：力扣（LeetCode） 双指针迭代： 定义双指针：pre 和 cur 局部反转：cur.next=pre pre 和 cur 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 123456789101112131415161718192021222324252627282930313233343536373839404142public class reverseNode { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static void printList(ListNode head) { ListNode cur = head; while (cur != null) { System.out.printf(\"%d \", cur.val); cur = cur.next; } } public static void main(String[] args) { ListNode node5 = new ListNode(5, null); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); ListNode pre = reverseList(node1); printList(pre); }} 时间复杂度：O(n)空间复杂度：O(1) 双指针迭代：另一种思路，充分运用head头节点 12345678910111213public static ListNode reverseList(ListNode head) { if (head == null) { return null; } ListNode cur = head; while (head.next != null) { ListNode tmp = head.next.next; head.next.next = cur; cur = head.next; head.next = tmp; } return cur;} 时间复杂度：O(n)空间复杂度：O(1) 递归： 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789public static ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode cur = reverseList(head.next); head.next.next = head; head.next = null; return cur;} 时间复杂度：O(n)空间复杂度：O(n) 空间复杂度指的是执行算法需要的辅助存储空间相对于数据规模的增长关系，算的是变量的个数，对于递归程序，每递归一次都在栈上开辟一块内存，所以递归了多少次就开辟了多少块内存，开辟的那些内存就是空间复杂度，因为递归了n次，所以递归的空间复杂度为O(n)。","link":"/2022/07/29/Reverse%20Linked%20List/"},{"title":"Basic Concepts","text":"参考：高频问题总结 操作系统操作系统、进程管理、文件系统、内存IO模型 进程和线程的区别？ 进程是资源分配的最小单位，线程是任务执行，运算调度的最小单位，不能单独存在，包含在进程中。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 进程的调度算法有哪些？ 先来先服务调度 短作业优先调度 优先级调度 高响应比优先调度 时间片轮转调度 多级反馈队列调度 常用 IO 模型？关注消息通信机制: a) 同步：调用一个功能，在功能结果没有返回之前，一直等待结果返回。 b) 异步：调用一个功能，调用立刻返回，但调用者不能立刻得到结果。调用者可以继续后续的操作，其结果一般通过状态，回调函数来通知调用者。 等待调用结果时的状态： 阻塞：调用一个函数，当调用结果返回之前，当前线程会被挂起，只有得到结果之后才会返回。 非阻塞：调用一个函数，不能立刻得到结果之前，调用不能阻塞当前线程。一个输入操作通常包括两个阶段： 等待数据准备好 从内核向进程复制数据 对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。 阻塞 IO 模型：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。 非阻塞IO模型：进程发起 IO 系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。 IO 复用模型：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。（在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。） 信号驱动 IO 模型：当进程发起一个 IO 操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用 IO 读取数据。 异步 IO 模型：当进程发起一个 IO 操作，进程返回不阻塞，但也不能返回结果；内核把整个 IO 处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。","link":"/2022/08/30/Basic%20Concepts/"},{"title":"ClassLoader","text":"来源：ClassLoader in Java The&nbsp;Java ClassLoader&nbsp;is a part of the&nbsp;Java Runtime Environment&nbsp;that dynamically loads Java classes into the&nbsp;Java Virtual Machine. The Java run time system does not need to know about files and file systems because of classloaders. Java classes&nbsp;aren’t loaded into memory all at once, but when required by an application. At this point, the&nbsp;Java ClassLoader&nbsp;is called by the&nbsp;JRE&nbsp;and these ClassLoaders load classes into memory dynamically. Types of ClassLoaders in JavaNot all classes are loaded by a single ClassLoader. Depending on the type of class and the path of class, the ClassLoader that loads that particular class is decided. To know the ClassLoader that loads a class the&nbsp;getClassLoader()&nbsp;method is used. All classes are loaded based on their names and if any of these classes are not found then it returns a&nbsp;NoClassDefFoundError&nbsp;or&nbsp;ClassNotFoundException. A Java Classloader is of&nbsp;three types: BootStrap ClassLoader: &nbsp;A Bootstrap Classloader is a Machine code which kickstarts the operation when the JVM calls it. It is not a java class. Its job is to load the first pure Java ClassLoader. Bootstrap ClassLoader loads classes from the location&nbsp;rt.jar. Bootstrap ClassLoader doesn’t have any parent ClassLoaders. It is also called as the&nbsp;Primodial ClassLoader. Extension ClassLoader: &nbsp;The Extension ClassLoader is a child of Bootstrap ClassLoader and loads the extensions of core java classes from the respective JDK Extension library. It loads files from&nbsp;jre/lib/ext&nbsp;directory or any other directory pointed by the system property&nbsp;java.ext.dirs. System ClassLoader: &nbsp;An Application ClassLoader is also known as a System ClassLoader. It loads the Application type classes found in the environment variable&nbsp;CLASSPATH, -classpath or -cp command line option. The Application ClassLoader is a child class of Extension ClassLoader. Note: The ClassLoader Delegation Hierarchy Model always functions in the order Application ClassLoader-&gt;Extension ClassLoader-&gt;Bootstrap ClassLoader. The Bootstrap ClassLoader is always given the higher priority, next is Extension ClassLoader and then Application ClassLoader. Principles of functionality of a Java ClassLoader Principles of functionality are the set of rules or features on which a Java ClassLoader works. There are three principles of functionality, they are: Delegation Model: The Java Virtual Machine and the Java ClassLoader use an algorithm called the&nbsp;Delegation Hierarchy Algorithm&nbsp;to Load the classes into the Java file.The ClassLoader works based on a set of operations given by the delegation model. They are: ClassLoader always follows the&nbsp;Delegation Hierarchy Principle. Whenever JVM comes across a class, it checks whether that class is already loaded or not. If the Class is already loaded in the method area then the JVM proceeds with execution. If the class is not present in the method area then the JVM asks the Java ClassLoader Sub-System to load that particular class, then ClassLoader sub-system hands over the control to&nbsp;Application ClassLoader. Application ClassLoader then delegates the request to Extension ClassLoader and the&nbsp;Extension ClassLoader&nbsp;in turn delegates the request to&nbsp;Bootstrap ClassLoader. Bootstrap ClassLoader will search in the Bootstrap classpath(JDK/JRE/LIB). If the class is available then it is loaded, if not the request is delegated to Extension ClassLoader. Extension ClassLoader searches for the class in the Extension Classpath(JDK/JRE/LIB/EXT). If the class is available then it is loaded, if not the request is delegated to the Application ClassLoader. Application ClassLoader searches for the class in the Application Classpath. If the class is available then it is loaded, if not then a&nbsp;ClassNotFoundException&nbsp;exception is generated. Visibility Principle: The&nbsp;Visibility Principle&nbsp;states that a class loaded by a parent ClassLoader is visible to the child ClassLoaders but a class loaded by a child ClassLoader is not visible to the parent ClassLoaders. Suppose a class GEEKS.class has been loaded by the Extension ClassLoader, then that class is only visible to the Extension ClassLoader and Application ClassLoader but not to the Bootstrap ClassLoader. If that class is again tried to load using Bootstrap ClassLoader it gives an exception&nbsp;java.lang.ClassNotFoundException. Uniqueness Property: The&nbsp;Uniquesness Property&nbsp;ensures that the classes are unique and there is no repetition of classes. This also ensures that the classes loaded by parent classloaders are not loaded by the child classloaders. If the parent class loader isn’t able to find the class, only then the current instance would attempt to do so itself. Methods of Java.lang.ClassLoaderAfter the JVM requests for the class, a few steps are to be followed in order to load a class. The Classes are loaded as per the delegation model but there are a few important Methods or Functions that play a vital role in loading a Class. loadClass(String name, boolean resolve) : This method is used to load the classes which are referenced by the JVM. It takes the name of the class as a parameter. This is of type loadClass(String, boolean). defineClass() : The defineClass() method is a&nbsp;final&nbsp;method and cannot be overriden. This method is used to define a array of bytes as an instance of class. If the class is invalid then it throws&nbsp;ClassFormatError. findClass(String name) : This method is used to find a specified class. This method only finds but doesn’t load the class. findLoadedClass(String name) : This method is used to verify whether the Class referenced by the JVM was previously loaded or not. Class.forName(String name, boolean initialize, ClassLoader loader) : This method is used to load the class as well as initialize the class. This method also gives the option to choose any one of the ClassLoaders. If the ClassLoader parameter is NULL then Bootstrap ClassLoader is used. Example: &nbsp;The following code is executed before a class is loaded: 1234567891011121314151617181920protected synchronized Class&lt;?&gt;loadClass(String name, boolean resolve) throws ClassNotFoundException{ Class c = findLoadedClass(name); try { if (c == NULL) { if (parent != NULL) { c = parent.loadClass(name, false); } else { c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { System.out.println(e); } }} Note: If a class has already been loaded, it returns it. Otherwise, it delegates the search for the new class to the parent class loader. If the parent class loader doesn’t find the class,&nbsp;loadClass() &nbsp;calls the method&nbsp;findClass() &nbsp;to find and load the class. The&nbsp;findClass() &nbsp;method searches for the class in the current&nbsp;ClassLoader&nbsp;if the class wasn’t found by the parent&nbsp;ClassLoader.","link":"/2022/05/27/ClassLoader/"},{"title":"Binary Search Tree","text":"参考：二叉排序树 数组和链表对数据的存取 链表 数组 存取方式 只能顺序 顺序，随机 存储位置 不一定 逻辑上相邻的元素实际物理存储也相邻 存储空间 依赖指针，存储密度低 存储密度相对较高 按值查找 O(n) 无序：O(n)；有序，折半查找O(logn) 索引查找 不支持随机访问，O(n) 可以随机访问，O(1) 插入删除 修改指针即可 平均需要移动$n/2$个元素 空间分配 按需申请，内存有空间即可分配 静态，存储元素数量受限；动态，虽然存储空间可以扩充，需要移动大量元素，操作效率低，如果内存没有更大的连续存储空间，分配失败 利用树来存取，既可以保证数据的检索，同时也可以保证数据的插入，删除，修改的速度。 Given preorder traversal of a binary search tree, construct the BST. For example, if the given traversal is {10, 5, 1, 7, 40, 50}, then the output should be the root of the following tree. Method 1time complexity: $O(n^2)$ The first element of preorder traversal is always root. We first construct the root. Then we find the index of the first element which is greater than the root. Let the index be ‘i’. The values between root and ‘i’ will be part of the left subtree, and the values between ‘i’(inclusive) and ‘n-1’ will be part of the right subtree. Divide given pre[] at index “i” and recur for left and right sub-trees. In {10, 5, 1, 7, 40, 50}, 10 is the first element, so we make it root. Now we look for the first element greater than 10, we find 40. So we know the structure of BST is as following. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Java program to construct BST from given preorder// traversal// A binary tree nodeclass Node { int data; Node left, right; Node(int d) { data = d; left = right = null; }}class Index { int index = 0;}class BinaryTree { Index index = new Index(); // A recursive function to construct Full from pre[]. // preIndex is used to keep track of index in pre[]. Node constructTreeUtil(int pre[], Index preIndex, int low, int high, int size) { // Base case if (preIndex.index &gt;= size || low &gt; high) { return null; } // The first node in preorder traversal is root. So // take the node at preIndex from pre[] and make it // root, and increment preIndex Node root = new Node(pre[preIndex.index]); preIndex.index = preIndex.index + 1; // If the current subarray has only one element, no // need to recur if (low == high) { return root; } // Search for the first element greater than root int i; for (i = low; i &lt;= high; ++i) { if (pre[i] &gt; root.data) { break; } } // Use the index of element found in preorder to // divide preorder array in two parts. Left subtree // and right subtree root.left = constructTreeUtil( pre, preIndex, preIndex.index, i - 1, size); root.right = constructTreeUtil(pre, preIndex, i, high, size); return root; } // The main function to construct BST from given // preorder traversal. This function mainly uses // constructTreeUtil() Node constructTree(int pre[], int size) { return constructTreeUtil(pre, index, 0, size - 1, size); } // A utility function to print inorder traversal of a // Binary Tree void printInorder(Node node) { if (node == null) { return; } printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } // Driver code public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int pre[] = new int[] { 10, 5, 1, 7, 40, 50 }; int size = pre.length; Node root = tree.constructTree(pre, size); System.out.println( \"Inorder traversal of the constructed tree is \"); tree.printInorder(root); }} Method 2time complexity: O(n) The trick is to set a range {min .. max} for every node. Initialize the range as {INT_MIN .. INT_MAX}. The first node will definitely be in range, so create a root node. To construct the left subtree, set the range as {INT_MIN …root-&gt;data}. If a value is in the range {INT_MIN .. root-&gt;data}, the values are part of the left subtree. To construct the right subtree, set the range as {root-&gt;data..max .. INT_MAX}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// Java program to construct BST from given preorder// traversal// A binary tree nodeclass Node { int data; Node left, right; Node(int d) { data = d; left = right = null; }}class Index { int index = 0;}class BinaryTree { Index index = new Index(); // A recursive function to construct BST from pre[]. // preIndex is used to keep track of index in pre[]. Node constructTreeUtil(int pre[], Index preIndex, int key, int min, int max, int size) { // Base case if (preIndex.index &gt;= size) { return null; } Node root = null; // If current element of pre[] is in range, then // only it is part of current subtree if (key &gt; min &amp;&amp; key &lt; max) { // Allocate memory for root of this // subtree and increment *preIndex root = new Node(key); preIndex.index = preIndex.index + 1; if (preIndex.index &lt; size) { // Construct the subtree under root // All nodes which are in range {min .. key} // will go in left subtree, and first such // node will be root of left subtree. root.left = constructTreeUtil( pre, preIndex, pre[preIndex.index], min, key, size); } if (preIndex.index &lt; size) { // All nodes which are in range {key..max} // will go in right subtree, and first such // node will be root of right subtree. root.right = constructTreeUtil( pre, preIndex, pre[preIndex.index], key, max, size); } } return root; } // The main function to construct BST from given // preorder traversal. This function mainly uses // constructTreeUtil() Node constructTree(int pre[], int size) { int preIndex = 0; return constructTreeUtil(pre, index, pre[0], Integer.MIN_VALUE, Integer.MAX_VALUE, size); } // A utility function to print inorder traversal of a // Binary Tree void printInorder(Node node) { if (node == null) { return; } printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } // Driver code public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int pre[] = new int[] { 10, 5, 1, 7, 40, 50 }; int size = pre.length; // Function call Node root = tree.constructTree(pre, size); System.out.println( \"Inorder traversal of the constructed tree is \"); tree.printInorder(root); }}","link":"/2022/09/01/Binary-Search-Tree/"}],"tags":[{"name":"Reading","slug":"Reading","link":"/tags/Reading/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"Iterative","slug":"Iterative","link":"/tags/Iterative/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","link":"/tags/StringBuffer/"},{"name":"StringBuilder","slug":"StringBuilder","link":"/tags/StringBuilder/"},{"name":"GC","slug":"GC","link":"/tags/GC/"},{"name":"Vocabulary","slug":"Vocabulary","link":"/tags/Vocabulary/"},{"name":"Two pointers","slug":"Two-pointers","link":"/tags/Two-pointers/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Traverse","slug":"Traverse","link":"/tags/Traverse/"},{"name":"Auxiliary Stack","slug":"Auxiliary-Stack","link":"/tags/Auxiliary-Stack/"},{"name":"HashSet","slug":"HashSet","link":"/tags/HashSet/"},{"name":"Fast and slow pointers","slug":"Fast-and-slow-pointers","link":"/tags/Fast-and-slow-pointers/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Process","slug":"Process","link":"/tags/Process/"},{"name":"Schedule","slug":"Schedule","link":"/tags/Schedule/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"JRE","slug":"JRE","link":"/tags/JRE/"},{"name":"IO Model","slug":"IO-Model","link":"/tags/IO-Model/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"}],"categories":[{"name":"Tips","slug":"Tips","link":"/categories/Tips/"},{"name":"News","slug":"News","link":"/categories/News/"},{"name":"Concepts","slug":"Concepts","link":"/categories/Concepts/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"Summary","slug":"Summary","link":"/categories/Summary/"}]}