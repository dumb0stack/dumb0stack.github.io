{"pages":[{"title":"About","text":"Gallery Netease","link":"/about/index.html"}],"posts":[{"title":"2 IELTS Reading Tips Which Will Get You Band 8","text":"来源：2 IELTS Reading Tips Which Will Get You Band 8 Getting Band 8 in IELTS reading is a difficult task but not impossible. For achieving 8 Band, you must concentrate a lot and have a prior sound strategy in your mind that could be implemented well on the day of your IELTS exam. If you are giving IELTS Academic exam, you must score 35 out of 40 to achieve Band 8 score which means you can afford to do hardly 5 mistakes in your exam. On the other hand, you must score 37 out of 40 for achieving a band score of 8 in IELTS General Training which implies you can only make 3 mistakes in your exam. IELTS candidates who were successful in receiving Band 9 have given some extremely useful tips that can help you get high band score in IELTS reading. Let us discuss what these top secrets of Band 8 are: Solving Questions Simultaneously While Reading PassageThe foremost thing that you as an IELTS candidate must be aware of is that you get your answers from the passage in the order of questions. For example, answer to question 1 in paragraph 2, answer to question 2 in paragraph 4 and so on. In this example case, you would never get answer to question 2 before the statement in paragraph 2 where you had received answer for question 1. For this reason, you can adopt an excellent strategy that works really well in IELTS reading and which is nothing but solving the questions side by side while you are reading the passage. For instance, first read question 1 and then start reading the passage to find its answer. Once you get answer for this question, go to question 2 and again start reading the passage from where you had stopped. In this manner, you would not be required to waste your time in reading the whole passage and you would be quickly finding out answers in no time. By doing this, you would never complain to be out of time while solving the questions in IELTS reading exam. Marking Answers in the Reading PassageOne of the effective strategies given by a candidate, who appeared in IELTS exam and received Band 9, is that you can mark answers in your reading passage rather than writing them first on the question paper and then transferring in your sheet which would consume double the time unnecessarily. Not only minutes but even seconds can be costly enough for losing out a particular question. Hence if you save some time, you are able to devote that saved time in solving a new question. Now, you cannot mark answers in reading passage for all the questions. Short answers, summary completion, flow chart, diagram labelling, fill-ups etc. are the questions where you can use this strategy. Basically, the questions where you are to write words, you can mark them in the passage itself and then transfer these answers quickly after you solve one passage rather than first writing the answers alongside the question and then transferring in your answer sheet. This will certainly save your time and help you get good score in IELTS reading.","link":"/2022/08/26/2-IELTS-Reading-Tips-Which-Will-Get-You-Band-8/"},{"title":"Climbing Stairs","text":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 12345Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 123456Input: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 来源：力扣（LeetCode） 超时解法：无脑递归1234567891011public class climbStairs { public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; return climbStairs(n - 1) + climbStairs(n - 2); } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：$O(2^n)$ （每层递归的complexity是上一层的2倍）空间复杂度：$O(n)$ （递归层数） 为什么这里空间复杂度是O(n)? 递归的空间复杂度是：递归的深度*每次递归所需的辅助空间的个数 辅助空间指的是为局部变量和形参所开辟的空间，对于递归算法，由于运行时有附加堆栈，所以递归的空间复杂度是递归的深度*每次压栈所需的空间个数。 递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数递归最深的那一次所耗费的空间足以容纳它所有递归过程。（递归是要返回上一层的，所以它所需要的空间不是一直累加起来的） 所以最深的那次压栈就是递归的空间复杂度。递归的深度是n，而每次递归所需的辅助空间个数为1。 由上图可知，很多节点重复求解多次，所以可以使用HashMap来保存求解过程中已经求过的值。 HashMap12345678910111213141516171819202122import java.util.HashMap;import java.util.Map;public class climbStairs { private static Map&lt;Integer, Integer&gt; storeMap = new HashMap&lt;&gt;(); public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; if (storeMap.get(n) != null) { return storeMap.get(n); } else { int result = climbStairs(n - 1) + climbStairs(n - 2); storeMap.put(n, result); return result; } } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：O(n) （链表）空间复杂度：O(n) （存储桶，链表） JDK1.8之前，HashMap底层实现用的是数组+链表，HashMap通过hash计算key的哈希值，然后hash%n（n为数组长度，初始化数组默认长度为16），得到key在数组中存放的下标；当出现哈希冲突时（两个key在数组中存放的下标一致），数据以链表形式存储；在链表中查找数据必须从第一个元素开始一层一层地往下找，直到找到为止，时间复杂度为O(n)，所以当链表长度越来越长时，HashMap的效率越来越低。 JDK1.8之后，corporate into了红黑树，当链表中的元素超过8（TREEIFY_THRESHOLD），并且数组长度大于64（MIN_TREEIFY_CAPACITY）时，会将链表转换为红黑树，转换之后数据查询的时间复杂度从O(n)降至O(logn)。 递归转循环12345678910111213public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int result = 0; int pre = 2; int prePre = 1; for (int i = 3; i &lt;= n; ++i) { result = pre + prePre; prePre = pre; pre = result; } return result;} 时间复杂度：O(n)空间复杂度：O(1) （辅助空间是常数级别的）","link":"/2022/08/20/Climbing-Stairs/"},{"title":"Decode String","text":"给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像&nbsp;3a&nbsp;或&nbsp;2[4]&nbsp;的输入。 12输入：s = \"3[a]2[bc]\"输出：\"aaabcbc\" 来源：力扣（LeetCode） StringBuilder12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class StringDecoding { public static String decodeString(String s) { StringBuilder res = new StringBuilder(); int multi = 0; Stack&lt;Integer&gt; stack_multi = new Stack&lt;Integer&gt;(); Stack&lt;String&gt; stack_res = new Stack&lt;String&gt;(); for (Character c : s.toCharArray()) { if (c == '[') { stack_multi.push(multi); stack_res.push(res.toString()); multi = 0; res = new StringBuilder(); } else if (c == ']') { StringBuilder tmp = new StringBuilder(); int cur_multi = stack_multi.pop(); for (int i = 0; i &lt; cur_multi; i++) { tmp.append(res); } res = new StringBuilder(stack_res.pop() + tmp); } else if (c &gt;= '0' &amp;&amp; c &lt;= '9') { multi = multi * 10 + c - '0'; } else res.append(c); } return res.toString(); } public static void main(String[] args) { String s = \"3[a]2[bc]\"; System.out.println(decodeString(s)); }} String、StringBuffer与StringBuilder String StringBuffer StringBuilder String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。也由于它的不可变性，类似拼接、裁剪字符串等动作，每次对String的操作都会生成新的 String对象。 为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，减小了开销，是绝大部分情况下进行字符串拼接的首选。 StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 参考：https://www.joshua317.com/article/241 StringBuilder和String可以相互转换 String-&gt;StringBuilder：可以使用StringBuilder的构造方法，StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder-&gt;String：可以使用StringBuilder中的toString方法。public String toString() 将当前StringBuilder对象转换为String对象。 Integer.parseInt(String s)具有参数类型String，而不是number.charAt(i)返回的char。 转换为String： 1a.add(Integer.parseInt(\"\" + number.charAt(i)));","link":"/2022/08/17/Decode-String/"},{"title":"Garbage Collection","text":"来源：Garbage Collection in Java Automatic Garbage Collection - Java automatically allocates and deallocates memory so programs are not burdened with that task. Garbage Collection in JavaGarbage collection in Java is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine, or JVM for short. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory. What is Garbage Collection?In C/C++, a programmer is responsible for both the creation and destruction of objects. Usually, programmer neglects the destruction of useless objects. Due to this negligence, at a certain point, sufficient memory may not be available to create new objects, and the entire program will terminate abnormally, causing OutOfMemoryErrors. But in Java, the programmer need not care for all those objects which are no longer in use. Garbage collector destroys these objects. The main objective of Garbage Collector is to free heap memory by destroying unreachable objects. The garbage collector is the best example of the Daemon thread as it is always running in the background. How Does Garbage Collection in Java works?Java garbage collection is an automatic process. Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in-use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused or unreferenced object is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed. The programmer does not need to mark objects to be deleted explicitly. The garbage collection implementation lives in the JVM. Types of Activities in Java Garbage CollectionTwo types of garbage collection activity usually happen in Java. These are: Minor or incremental Garbage Collection: It is said to have occurred when unreachable objects in the young generation heap memory are removed. Major or Full Garbage Collection: It is said to have occurred when the objects that survived the minor garbage collection are copied into the old generation or permanent generation heap memory are removed. When compared to the young generation, garbage collection happens less frequently in the old generation. Important Concepts Related to Garbage Collection in JavaUnreachable objects:An object is said to be unreachable if it doesn’t contain any reference to it. Also, note that objects which are part of the island of isolation are also unreachable. 1234Integer i = new Integer(4);// the new Integer object is reachable via the reference in 'i' i = null;// the Integer object is no longer reachable. Eligibility for garbage collection:An object is said to be eligible for GC(garbage collection) if it is unreachable. After i = null, integer object 4 in the heap area is suitable for garbage collection in the above image. Ways to make an object eligible for Garbage Collector Even though the programmer is not responsible for destroying useless objects but it is highly recommended to make an object unreachable(thus eligible for GC) if it is no longer required. There are generally four ways to make an object eligible for garbage collection. Nullifying the reference variable Re-assigning the reference variable An object created inside the method Island of Isolation Ways for requesting JVM to run Garbage Collector Once we make an object eligible for garbage collection, it may not destroy immediately by the garbage collector. Whenever JVM runs the Garbage Collector program, then only the object will be destroyed. But when JVM runs Garbage Collector, we can not expect. We can also request JVM to run Garbage Collector. There are two ways to do it : Using System.gc() method: System class contain static method gc() for requesting JVM to run Garbage Collector. Using Runtime.getRuntime().gc() method: Runtime class allows the application to interface with the JVM in which the application is running. Hence by using its gc() method, we can request JVM to run Garbage Collector. There is no guarantee that any of the above two methods will run Garbage Collector. The call System.gc() is effectively equivalent to the call : Runtime.getRuntime().gc() Finalization Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object. finalize() method is present in Object class with the following prototype. 1protected void finalize() throws Throwable Based on our requirement, we can override finalize() method for performing our cleanup activities like closing connection from the database. The finalize() method is called by Garbage Collector, not JVM. However, Garbage Collector is one of the modules of JVM. Object class finalize() method has an empty implementation. Thus, it is recommended to override the finalize() method to dispose of system resources or perform other cleanups. The finalize() method is never invoked more than once for any object. If an uncaught exception is thrown by the finalize() method, the exception is ignored, and the finalization of that object terminates. Advantages of Garbage Collection in JavaThe advantages of Garbage Collection in Java are: It makes java memory-efficient because the garbage collector removes the unreferenced objects from heap memory. It is automatically done by the garbage collector(a part of JVM), so we don’t need extra effort. Real-World ExampleLet’s take a real-life example, where we use the concept of the garbage collector. Question: Suppose you go for the internship at GeeksForGeeks, and you were told to write a program to count the number of employees working in the company(excluding interns). To make this program, you have to use the concept of a garbage collector. Write a program to create a class called Employee having the following data members. An ID for storing unique id allocated to every employee. Name of employee. age of an employee. Also, provide the following methods: A parameterized constructor to initialize name and age. The ID should be initialized in this constructor. A method show() to display ID, name, and age. A method showNextId() to display the ID of the next employee. Tuning GuideGarbage Collector Implementation Now any beginner, who doesn’t know Garbage Collector in Java will code like this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Java Program to count number// of employees working// in a company class Employee { private int ID; private String name; private int age; private static int nextId = 1; // it is made static because it // is keep common among all and // shared by all objects public Employee(String name, int age) { this.name = name; this.age = age; this.ID = nextId++; } public void show() { System.out.println(\"Id=\" + ID + \"\\nName=\" + name + \"\\nAge=\" + age); } public void showNextId() { System.out.println(\"Next employee id will be=\" + nextId); }} class UseEmployee { public static void main(String[] args) { Employee E = new Employee(\"GFG1\", 56); Employee F = new Employee(\"GFG2\", 45); Employee G = new Employee(\"GFG3\", 25); E.show(); F.show(); G.show(); E.showNextId(); F.showNextId(); G.showNextId(); { // It is sub block to keep // all those interns. Employee X = new Employee(\"GFG4\", 23); Employee Y = new Employee(\"GFG5\", 21); X.show(); Y.show(); X.showNextId(); Y.showNextId(); } // After countering this brace, X and Y // will be removed.Therefore, // now it should show nextId as 4. // Output of this line E.showNextId(); // should be 4 but it will give 6 as output. }} output123456789101112131415161718192021Id=1Name=GFG1Age=56Id=2Name=GFG2Age=45Id=3Name=GFG3Age=25Next employee id will be=4Next employee id will be=4Next employee id will be=4Id=4Name=GFG4Age=23Id=5Name=GFG5Age=21Next employee id will be=6Next employee id will be=6Next employee id will be=6 Now to get the correct output: Now garbage collector(gc) will see 2 objects free. Now to decrement nextId,gc(garbage collector) will call method to finalize() only when we programmers have overridden it in our class. And as mentioned previously, we have to request gc(garbage collector), and for this, we have to write the following 3 steps before closing brace of sub-block. Set references to null(i.e X = Y = null;) Call, System.gc(); Call, System.runFinalization(); Now the correct code for counting the number of employees(excluding interns) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Correct code to count number// of employees excluding interns. class Employee { private int ID; private String name; private int age; private static int nextId = 1; // it is made static because it // is keep common among all and // shared by all objects public Employee(String name, int age) { this.name = name; this.age = age; this.ID = nextId++; } public void show() { System.out.println(\"Id=\" + ID + \"\\nName=\" + name + \"\\nAge=\" + age); } public void showNextId() { System.out.println(\"Next employee id will be=\" + nextId); } protected void finalize() { --nextId; // In this case, // gc will call finalize() // for 2 times for 2 objects. }} public class UseEmployee { public static void main(String[] args) { Employee E = new Employee(\"GFG1\", 56); Employee F = new Employee(\"GFG2\", 45); Employee G = new Employee(\"GFG3\", 25); E.show(); F.show(); G.show(); E.showNextId(); F.showNextId(); G.showNextId(); { // It is sub block to keep // all those interns. Employee X = new Employee(\"GFG4\", 23); Employee Y = new Employee(\"GFG5\", 21); X.show(); Y.show(); X.showNextId(); Y.showNextId(); X = Y = null; System.gc(); System.runFinalization(); } E.showNextId(); }} output123456789101112131415161718192021Id=1Name=GFG1Age=56Id=2Name=GFG2Age=45Id=3Name=GFG3Age=25Next employee id will be=4Next employee id will be=4Next employee id will be=4Id=4Name=GFG4Age=23Id=5Name=GFG5Age=21Next employee id will be=6Next employee id will be=6Next employee id will be=4","link":"/2022/08/30/Garbage%20Collection/"},{"title":"Designed to Last: 10 of the world's most ingenious building","text":"来源：Designed to Last: 10 of the world’s most ingenious buildings Why abandon buildings once they’re no longer needed? A new book reveals the best projects finding new uses for factories, grain silos and market halls. For BBC Culture’s new series Designed to Last, here are 10 of the most ingenious – and inspiring – spaces around the globe. “The shifts in how we live and work have radically altered our cities,” writes Ruth Lang in new Gestalten book Building for Change: The Architecture of Creative Reuse. “The spatial demands of working patterns have been utterly transformed over the past 50 years.” Many of our buildings could last for 50, or even 100, years; yet “fashion and changing patterns of use often curtail this lifespan, which sometime barely stretches to a decade”. Instead of abandoning these structures, however, designers are developing innovative solutions “which find value in the buildings that have been left behind… in place of our obsession with newness”. Building for Change explores how creative reuse could be the way forward for designing spaces around the world. While some architects are restoring and adapting existing buildings to meet new purposes, others are designing structures that can be readily repurposed for alternative uses further down the line. As Lang writes, “innovation doesn’t always have to mean creating anew – it can mean approaching existing resources in new ways”. Even within those parameters, ambitiously creative designs are still possible – ones “that push the limits of architectural imagination”. Here, 10 projects – including former factories, sugar mills, grain silos and market halls – reveal the most ingenious, imaginative responses to an increasingly urgent global challenge. Building for Change: The Architecture of Creative Reuse is out now. Baoshan WTE Exhibition Centre, Shanghai, China Kokaistudios A former steel mill in Shanghai has been turned into an eco-park that includes a new thermo-electric waste-to-energy power plant, wetlands, an exhibition centre and offices. One of the last remaining industrial structures in the city’s Luojing neighbourhood, the factory is a heritage site. Architects Kokaistudios kept its structure intact, fitting an independent modular system of panelling around the existing steel frame, “reimagining its rusting pipework and machinery as a design feature rather than a problem to be dealt with”, according to Building for Change. The polycarbonate screens are reusable and lightweight, which “enables the interior spaces to be flexible in configuration, reducing costs and construction times for adaptations as the site develops and the users’ needs change”. They also mean that the site’s appearance is transformed “from ‘darkly overbearing’ to ‘warmly welcoming’ – even at night, when the building glows from within”. Kibera Hamlets School, Nairobi, KenyaSelgasCano and Helloeverything Just as the modular structure of Baoshan means that it can be dismantled and removed for future reuse on an alternative site, a project in Denmark embedded a second life into its initial design. “In accepting the commission to create a temporary pavilion for the Louisiana Museum of Modern Art near Copenhagen, Madrid studio SelgasCano and New York’s Helloeverything pre-empted an afterlife for their creation”, according to Building for Change. “They designed a structure that would not only suit the purposes of the brief, but which could be deconstructed, transported, and relocated elsewhere.” The former exhibition pavilion now houses a school for 600 pupils in Kibera, one of the largest urban slums in Africa. Dutch photographer Iwan Baan suggested the project’s new incarnation, which provides educational facilities for nursery, primary and secondary pupils in 12 enclosed classrooms. Exploiting the universal modular scaffolding system, which can easily be transported and adapted, the structure was constructed over two months by the architects and 20 members of the Kibera neighbourhood. Alila Yangshuo Hotel, Guangxi, ChinaVector Architects Surrounded by ancient villages in an ecologically-protected setting, this abandoned 1960s sugar mill has been converted into a luxury hotel by Vector Architects. The landscape is as much a feature of the site as the buildings, and a structural truss – previously used for transferring sugar cane to the boats on the Li River below – has been stripped back to its functional concrete core, which now frames a newly-built pool. The original construction of the buildings has been mostly kept and simplified, with one wing of the hotel acting as a sound barrier to the highway that runs alongside the site. Zeitz Museum of Contemporary Art Africa, Cape Town, South AfricaHeatherwick Studio This 1920s grain silo on Cape Town’s Victoria &amp; Alfred Waterfront was the tallest building in sub-Saharan Africa until the mid-1970s – and has been decommissioned since 1990. “The agricultural structure is an emblem of South Africa’s colonial history as well as another chapter in its post-Apartheid future,” according to Building for Change. “Its transformation fractures these historic associations without denying them, to form what… is renowned as the world’s largest museum dedicated to contemporary African and diaspora art.” London’s Heatherwick Studio carved into eight of the 42 reinforced concrete tubes that made up the grain lift and storage annex, to form 80 galleries across six levels, as well as a huge void at the centre “within which the nature and complexity of these spaces can finally be appreciated”. Kamikatsu Zero Waste Centre, Kamikatsu, JapanHiroshi Nakamura &amp; NAP “In 2003, after the forced decommissioning of its waste incinerator, the municipality issued a Zero Waste Declaration requiring all waste produced by the area’s residents to be reused or recycled to reduce the demands for landfill or incineration,” according to Building for Change. “Rather than increase emissions by shipping waste to the nearest city for processing, a new centre was created where residents can separate and source materials for recycling and reuse.” To challenge public perceptions of a “waste centre”, the site includes a shop selling reclaimed items, a community hall, a laundry, a hotel and an educational space for research into ways of increasing reuse. The horseshoe-shaped plan allows easy access to materials, while the centre’s construction incorporated waste materials from local houses, schools and government buildings left derelict by the area’s depopulation – including 700 retrieved windows that form the walls of the structure, bolstered by plastic crates once used for mushroom harvesting. Local residents now recycle 80% of their waste, compared to a national average of 20%. Qinglongwu Capsule Hotel and Library, Jinhua, ChinaAtelier tao+c The 20 capsule bedrooms in this former barn are surrounded by bookcases made from locally-sourced bamboo, while the bathrooms sit in the roof space. Architects Atelier tao+c staggered the bedrooms throughout the building, interspersed with double-height spaces which add to the sense of lightness created by a suspended framework. The self-contained construction is separate from the building’s skin, and in places, the steel grid is concealed within the bookcases, which provide a sense of privacy. EOI Melilla Language School, Melilla, SpainÁngel Verdasco Arquitectos One of two autonomous Spanish cities located in North Africa, Melilla borders Morocco. When its central market building closed in 2003, it “created a rupture in the neighbourhood’s cohesion”, according to Building for Change, as the 90-year-old commercial centre was a “social catalyst, connecting the city’s Christian, Muslim, and Jewish communities”. Ángel Verdasco Arquitectos won a 2008 competition seeking a design that embodied the market’s social value, their proposal transforming the site into a music academy, a language school and an educational centre for adults – providing “cross-cultural connectivity” that offers Melilla’s different communities a place to interact. The original market walls were left freestanding, enclosing the structures within and building upon “the memories and identity of the market, which might otherwise have been swept away”. An aluminium lattice frame is a contemporary reinterpretation of local Islamic architecture, mirroring perforated jail screens that control light and ventilation through an interior space. Inside, the derelict market hall was stripped back to its skin, within which “a new structure that echoes the social purpose of the historic building has been constructed”, according to Building for Change. “The centre acts as a mediating space for the different communities and functions that occupy the site,” and fosters multiculturalism “by reappropriating the market structure for its new purpose”. Castle Acre Water Tower, Norfolk, UKTonkin Liu “Built in 1952, this water tower in Norfolk, England, wasn’t originally deemed worthy of saving by local authorities,” according to Building for Change. “Previously housed on an airfield, it was subsequently auctioned as scrap.” Luckily, it was rescued by new owners, who converted the tower into their home. By cutting a ribbon window, replacing one line of the panelled steel grid that forms the walls of the tank, the architects produced panoramic views of the surrounding landscape. A timber stair enclosure braces the tower, preventing the roof from shifting against the lower level in high winds, while a stair tower acts as a thermal chimney, creating ventilation when the windows are closed. Waste materials were reused, with the unit clad in recycled aluminium-plastic panels, and the stair tower’s balustrade was made from steel tie rods that were removed from the tank. Tai Kwun Centre for Heritage and Arts, Hong KongHerzog &amp; de Meuron “Built as a compound by the British after taking control of Hong Kong in 1841, the Central Police Station, Central Magistracy and Victoria Prison have all since been listed. Along with 16 other historic buildings, they occupy… ‘the largest heritage conservation project in Hong Kong’”, according to Building for Change. The buildings were so old that they had no construction records, meaning that engineers needed to do a forensic investigation in order to plan an appropriate method of repair. There were other challenges when creating the two new structures: minimising vibration during works to avoid damaging existing buildings, and using innovative ways of creating foundations because of the high density of the site, which is now a cultural and shopping centre. Lakeside Plugin Tower, Beijing, ChinaPeople’s Architecture Office A prototype demonstrating the benefits of modular construction, located in an area of protected farmland, Lakeside Plugin Tower is intended to touch the ground lightly – minimising disruption to the ecology, water table and wildlife of the site, and enabling easy removal to other sites in the future. “The modules are designed for ease of transport from the factory where they are prefabricated, and can be assembled without skilled labourers,” according to Building for Change. A large variety of shapes and potential configurations “allow for a more creative assembly, enabling users to angle units to take advantage of views, and to create different combinations of textures and colours with the panels”. That changes the role of the architect, who gives up control over layout, shape, size and colour. It also extends the building’s lifespan almost indefinitely. “The house’s plug-in structure is designed to be added to and adapted over time, as shifts in technology and the needs of its occupants dictate.”","link":"/2022/08/30/Designed-to-Last-10-of-the-world-s-most-ingenious-building/"},{"title":"How to Expand Your Vocabulary","text":"来源：How to Expand Your Vocabulary? Lexical resource is a very important marking criterion in IELTS writing and speaking which implies using a wide range of vocabulary accurately. Apart from this, vocabulary knowledge will also help you a lot in reading. Thus, it is one of the reasons why students worry a lot for learning new words which they can use while they speak or write. Also, that candidates who receive less than 5 band have limited vocabulary while 7 band and above use a wide range of vocabulary and hence, vocabulary is essential for IELTS preparation.Let us consider some of the tips for expanding vocabulary. Read NewspapersReading is the best habit to learn new words and it will also help you to improve your skills for IELTS reading module. You can subscribe a daily or weekly newspaper online or offline and have the habit of reading articles on a daily basis. While you read articles, do underline the words that you do not know or notice carefully if you come to know about the use of a word in a different way. Then, check the word meaning in your dictionary and write down in your notebook. Learn the noted words and do revise them once or twice a week. Useful Links: http://www.bbc.com/news/http://www.economist.com/ Keep a DictionaryA very common method of learning vocabulary is to keep a small pocket-sized dictionary with you. If you never devoted time to learn new words in this way, you can develop this habit now. There are two ways you can use your dictionary to learn words. Firstly, you can refer it any time you come across a new word and check its meaning in the dictionary. Secondly, you can start learning the words in sequence from first to the last page of your dictionary. In this way, you can at least become familiar to new words every day and depending upon how much time you devote per day, you may be able to read all the words in your dictionary in several days or months. However, for effective learning, keep in mind to learn a word whole-heartedly. If you feel you cannot understand a word, just skip it because learning a word incorrectly is even more dangerous. Learn vocabulary effectively in the following way: Check the word meaning (in English and/or in your native language) Learn its right pronunciation Learn its synonyms Use this word to form a sentence Practice more and more while speaking and writing For example: Perception meaning– Ability to see through perceptionSynonyms – Awareness, recognitionExample: Different people have different perception about beauty. Useful Link: http://www.enchantedlearning.com/Aisfor.shtmlhttp://www.oxfordlearnersdictionaries.com/wordlist/english/academic/http://dictionary.cambridge.org/browse/pronunciation/http://www.thesaurus.com/browse/perception (Search a keyword to know synonyms) Listen to Audios &amp; Watch VideosThe best way of learning the usage of a new word is when you listen to it being used by others. So, you can watch TV programmes, news channels, movies, YouTube videos, group discussions, talk shows etc. You can also listen to audios such as podcasts, songs, radio channels etc. One more thing is that you can prefer watching or listening to the stuff that you find interesting so that you may not get bored and stop your plan to learn vocabulary. The concept behind this method is that you are exposed to new words and hence, you learn faster in this way. When you watch videos or listen to some audios, pay more attention to the words and how they are used. Watching video stuff online is also a good idea where you can pause or replay the videos to learn at your own pace. You can start by listening to videos which have sub-titles. This will help you improve your comprehension as well as listening skills. In case, you come across a new word, use the dictionary to find the meaning and at least one synonym. Learn with FunNowadays, there are many games available on the websites and game applications can also be installed in mobile phones which can be some of the most interesting and exciting ways to learn vocabulary. This will definitely help those who find it boring to read books. Useful Links: http://eslgamesworld.com/members/games/levels/high/index.html Learn Idioms &amp; ConnectivesUse of idiomatic language and sentence connectors while you speak on a topic would be effective. In academic writing task 1, you should use connectives while idioms can be be avoided as they are used for informal writing. And hence, students appearing in IELTS General Training may use them while writing a letter. But make sure you use them when required and do not unnecessarily try to include them excessively. Useful Link: http://idioms.thefreedictionary.com/ Practice is the key!Practicing using the vocabulary is extremely important, otherwise you will forget a word even after noting it down. Target number of words to be learnt daily and revise them every week by practicing their use in writing and speaking. In this way, you are really going to improve your knowledge of new words and getting familiar with them. The more you practice, the more you can use them naturally as it is also essential that you don’t hesitate while using the newly learnt words.Lastly, while you learn words, you can also further ensure that you know the correct use in terms of spelling, punctuation, usage in a sentence and collocation (combination of words)","link":"/2022/08/16/How%20to%20Expand%20Your%20Vocabulary/"},{"title":"How to Finish 3 IELTS Reading Comprehension in Less Than 60 Mins","text":"来源：How to Finish 3 IELTS Reading Comprehension in Less Than 60 Mins? It is often a big hurdle faced by many IELTS students to struggle for completing the IELTS reading exam in 1 hour and finishing it in less than 1 hour is unimaginable for them. However, if proper strategy is implemented, it is definitely possible to complete the 3 IELTS reading comprehension passages in less than 60 minutes. Let us know the right strategies for the same. Solve Questions While Reading PassagesIf you had been running out of time while solving IELTS reading passages, one of the best strategies, which absolutely works as the most practical solution, is that you should solve your questions while you are reading the passage for the first time. Usually, students are advised the protocol of first reading the passage and then solving questions. Instead of this, it would be better to read the question first and then start reading the passage. Once you find answer of first question, read the second question and then again start reading the passage from when you had left. By following this strategy, you would never complain about not completing the reading passages on time. Rather you would find some time left to review your answers as well. Transfer Answers SimultaneouslyAnother important tip that you should keep in mind is that you must transfer your answers simultaneously since you do not get extra time for this in IELTS reading. For this strategy, you can do one thing. First, solve one passage and mark the answers on the question paper. Once you are done with solving that passage, immediately transfer those marked answers on the answer sheet. This would also give you confidence on completing a passage and to avoid last minute rush of writing down answers in the answer sheet. Apart from this, you can also save time by marking the words in the passages instead of writing them on the question paper and then transfer to answer sheet from the passage itself. Divide Your Time EffectivelyRemember that you have only 60 minutes to solve 40 questions which are divided into 3 passages. Last passage is definitely going to be difficult and hence, you may devote some more time there. Implementing the effective time strategies would help you a lot in IELTS reading test. You should try to solve your first passage in less than 20 minutes. Similarly, you should also do second passage in less than 20 minutes so that you have some more minutes to solve third passage. Do Not Spend More Time on a Single QuestionWhile solving IELTS reading passages by following the above strategies, you also need to make sure that you are not devoting extra time on a single question. It is, for sure, going to be the case that a few questions are very difficult and to solve them, you may need peace of mind. Instead of spending more and more time on such difficult questions, if you move on and solve the other simple questions, you would save time and gain confidence as well. Later on, you can solve the pending questions or simply guess them but do make sure that those difficult questions are marked well otherwise you may forget to solve them.","link":"/2022/08/15/How-to-Finish-3-IELTS-Reading-Comprehension-in-Less-Than-60-Mins/"},{"title":"Intersection of Two Linked Lists","text":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. 注意，函数返回结果后，链表必须保持其原始结构。 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 12345输入：intersectVal&nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 来源：力扣（LeetCode） 双指针：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class intersectLinkedList { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } public ListNode() { } } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } public static void main(String[] args) { ListNode node1 = new ListNode(4); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(8); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); ListNode node6 = new ListNode(1); ListNode node7 = new ListNode(6); ListNode node8 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node8.next = node7; node7.next = node6; node6.next = node3; System.out.print(getIntersectionNode(node1, node8).val); }} 两链表从同一位置开始遍历：128 1 6 3 2 70 8 1 6 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class intersectLinkedList { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } public ListNode() { } } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { int L1 = 0, L2 = 0, diff = 0; ListNode head1 = headA, head2 = headB; while (head1 != null) { L1++; head1 = head1.next; } while (head2 != null) { L2++; head2 = head2.next; } if (L1 &lt; L2) { head1 = headB; head2 = headA; diff = L2 - L1; } else { head1 = headA; head2 = headB; diff = L1 - L2; } for (int i = 0; i &lt; diff; i++) head1 = head1.next; while (head1 != null &amp;&amp; head2 != null) { if (head1 == head2) return head1; head1 = head1.next; head2 = head2.next; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(8); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(6); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(2); ListNode node6 = new ListNode(7); ListNode node7 = new ListNode(0); ListNode node8 = new ListNode(2); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = node6; node7.next = node1; node3.next = node8; System.out.print(getIntersectionNode(node1, node7).val); }}","link":"/2022/08/07/Intersection-of-Two-Linked-Lists/"},{"title":"IELTS Reading- Sentence Completion Tips and Strategy","text":"来源：IELTS Reading- Sentence Completion Tips and Strategy These questions are as much vocabulary tests as they are reading tests because they require you to be aware of paraphrasing (using different words to repeat a sentence so that it has the same meaning) and synonyms (words with the same or very similar meanings). Task descriptionIn this kind of question you will be given a number of sentences with gaps in them and asked to complete the sentences with words from the reading text. How to approach this task Read the incomplete sentences first. Think about what word form can be used and try to predict the answer. Also think about keywords and how they could be represented by synonyms or paraphrasing. Locate where the information is located by scanning quickly. If you can’t locate the answer quickly, move on. Read the incomplete sentence again. Study the reading text more carefully to establish the answer. ExampleChoose the correct letter, A, B, C or D. 1 When Willis Carrier invented air conditioning, his aim was to A make workers feel cooler. B produce more attractive paper. C set up a new business. D solve problems in a factory. 2 Home air conditioners were not popular at first because they were A too big and expensive. B not considered necessary. C too inefficient. D complicated to use. 3 Employers refused to put air conditioning in workplaces at first because they A could not afford to pay for it. B thought it was more suitable for cinemas. C did not want to spend money improving working conditions. D thought people would not work so hard in comfortable conditions. Link: http://mini-ielts.com/822/reading/air-conditioning How to solve this test? Find where the answer is located in the text before you try to answer the question. Remember where before what. Read the questions before reading the text. Keyword table for this practice test: Keywords in Questions Similar words in Passage When Willis Carrier invented air conditioning, his aim was to solve problems in a factory Carrier’s invention made it possible to control temperature and humidity levels and so align the colours. Home air conditioners were not popular at first because they were too big and expensive. However, its size, similar to that of an early computer, meant it took up too much space to come into widespread use, and later models, such as the Weathermaker, which Carrier brought out in the 1920s, cost too much for most people. Employers refused to put air conditioning in workplaces at first because they did not want to spend money improving working conditions. They considered that if they were paying people to work, they should not be paying for them to be comfortable as well. Explanation:Question 1: Find the keywords in the reading passage that has similar words in the question:control temperature and humidity levels = solve problems in a factory So answer of Q1 is D. Question 2: Find the keywords in the reading passage that has similar words in the question: it took up too much space = too big ; cost too much = expensive So answer of Q2 is A. Question 3: Find the keywords in the reading passage that has similar words in the question: paying = spend money ; comfortable = improving working conditions So answer of Q3 is C. Now continue this technique with another questions. This may seem like a lot of work and in the beginning but once you have practised this many times, you will be able to find your answers really fast and with much better accuracy and that will improve your score. You can practice more this type of question at: http://mini-ielts.com/reading?search=&amp;q11=on&amp;count=&amp;sort=date-desc","link":"/2022/08/13/IELTS-Reading-Sentence-Completion-Tips-and-Strategy/"},{"title":"Implement Queue using Stacks","text":"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：你只能使用标准的栈操作 —— 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 来源：力扣（LeetCode） 构造的时候要时刻记住此方法非彼方法，一个自己实现的queue方法，一个是stack类提供的方法 123IsEmpty:false3 1 2 IsEmpty:true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Stack;class MyQueue { Stack&lt;Integer&gt; stack1; Stack&lt;Integer&gt; stack2; /** * Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } /** * Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { if (!stack1.isEmpty()) { in2out(); } return stack2.pop(); } /** * Get the front element. */ public int peek() { if (!stack1.isEmpty()) { in2out(); } return stack2.peek(); } /** * Returns whether the queue is empty. */ public boolean empty() { if (!stack1.isEmpty()) { return stack1.isEmpty(); } else return stack2.isEmpty(); } public void in2out() { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } public static void main(String[] args) { MyQueue queue = new MyQueue(); queue.push(3); queue.push(1); queue.push(2); System.out.println(\"IsEmpty:\" + queue.empty()); while (!queue.empty()) { System.out.print(queue.peek() + \" \"); queue.pop(); } System.out.println(\"\\nIsEmpty:\" + queue.empty()); }} 看似没什么问题，然而 是不是push写错了？ 12345678910public void push(int x) { if (!stack2.isEmpty()) { while (!stack2.isEmpty()) { Integer pop = stack2.pop(); stack1.push(pop); } stack1.push(x); } else stack1.push(x);} 事实上，这个方法没写全，如果stack2为空，将stack1中的元素全部放到stack2中 12345public void in2out() { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } 1234567public void in2out() { if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } }","link":"/2022/08/10/Implement-Queue-using-Stacks/"},{"title":"Leetcode Binary-Tree","text":"来源：Binary-Tree 二叉树的中序遍历 (94)12输入：root = [1,null,2,3]输出：[1,3,2] 递归 1234567891011121314public static List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); inorder(root, res); return res;}public static void inorder(TreeNode root, List&lt;Integer&gt; res) { if (root == null) { return; } inorder(root.left, res); res.add(root.val); inorder(root.right, res);} 非递归：迭代 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }}class Solution { public static List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); res.add(root.val); root = root.right; } return res; } public static void main(String[] args) { TreeNode root = new TreeNode(1); TreeNode n1 = new TreeNode(2); TreeNode n2 = new TreeNode(3); root.right = n1; n1.left = n2; List&lt;Integer&gt; rs = inorderTraversal(root); System.out.println(rs); }}","link":"/2022/08/30/Leetcode%20Binary-Tree/"},{"title":"Linked List Cycle","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;next&nbsp;pointer. Internally, pos&nbsp;is used to denote the index of the node that&nbsp;tail’s&nbsp;next&nbsp;pointer is connected to.&nbsp;Note that&nbsp;pos&nbsp;is not passed as a parameter. Return&nbsp;true if there is a cycle in the linked list. Otherwise, return false. 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 Follow up: Can you solve it using O(1) (i.e. constant) memory? 来源：力扣（LeetCode） 快慢指针：跑的快的总能套圈12345678910111213141516171819202122232425262728293031323334353637public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slowPtr = head, fastPtr = head; while (fastPtr.next != null &amp;&amp; fastPtr.next.next != null) { slowPtr = slowPtr.next; fastPtr = fastPtr.next.next; if (slowPtr == fastPtr) return true; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中的节点数）空间复杂度：O(1) （只使用了两个指针的额外空间） 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 n 轮。 HashSet不重复的添加，添加元素时会判断是否已经存在,已经存在会添加不成功 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashSet;import java.util.Set;public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { Set seen = new HashSet(); while (head != null) { if (!seen.add(head)) return true; head = head.next;// if (seen.contains(head)) return true;// seen.add(head);// head = head.next; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中节点数）空间复杂度：O(n) （主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次） https://blog.csdn.net/weixin_45453739/article/details/122644349 Relevant Problem给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 不允许修改链表。 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 进阶：你是否可以使用 O(1) 空间解决此题？ 快慢指针： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static ListNode detectCycle(ListNode head) { if (head == null) return null; ListNode tortoise = head, rabbit = head; boolean loopExists = false; while (rabbit.next != null &amp;&amp; rabbit.next.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; if (tortoise == rabbit) { loopExists = true; break; } } if (loopExists == true) { tortoise = head; while (tortoise != rabbit) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(detectCycle(node1).val); }}","link":"/2022/08/05/Linked-List-Cycle/"},{"title":"Palindrome Linked List","text":"Given the head of a singly linked list, return true if it is a palindrome or false otherwise. 12Input: head = [1,2,2,1]Output: true 12Input: head = [1,2]Output: false 来源：力扣（LeetCode） 快慢指针+反转链表：中规中矩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PalindromeLinkedList { public static class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseNode(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static boolean isPalindrome(ListNode head) { ListNode tortoise = head, rabbit = head; while (rabbit != null &amp;&amp; rabbit.next != null) { rabbit = rabbit.next.next; tortoise = tortoise.next; } if (rabbit != null) tortoise = tortoise.next; //如果链表为奇数节点，慢指针指向下一个节点，把正中间节点让给左边 tortoise = reverseNode(tortoise); rabbit = head; while (tortoise != null) { if (tortoise.val != rabbit.val) return false; rabbit = rabbit.next; tortoise = tortoise.next; } return true; } public static void main(String[] args) { ListNode node4 = new ListNode(1, null); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); System.out.print(isPalindrome(node1)); }} 合一块 12345678910111213141516171819202122232425public static boolean isPalindrome(ListNode head) { if (head == null || head.next == null) { return true; } ListNode slow = head, fast = head; ListNode pre = null; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; ListNode temp = slow.next; slow.next = pre; pre = slow; slow = temp; } if (fast != null) { slow = slow.next; } while (pre != null &amp;&amp; slow != null) { if (pre.val != slow.val) { return false; } pre = pre.next; slow = slow.next; } return true;} Relevant Problem 1Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 来源：力扣（LeetCode） 123Input: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3. 123Input: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. 天然适配双指针： 123456789101112131415161718192021222324252627282930313233343536373839public class MiddleOfTheLinkedList { public static class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode middleNode(ListNode head) { ListNode tortoise = head, rabbit = head; while (rabbit != null &amp;&amp; rabbit.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; } return tortoise; } public static void main(String[] args) { ListNode node6 = new ListNode(6, null); ListNode node5 = new ListNode(5, node6); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); System.out.println(middleNode(node1).val); }} Relevant Problem 2剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 来源：力扣（LeetCode） 12给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 快慢指针：12345678910111213141516171819202122232425262728293031323334353637public class BottomK { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode getKthFromEnd(ListNode head, int k) { ListNode tortoise = head, rabbit = head; while (k-- != 0) { rabbit = rabbit.next; } while (rabbit != null) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(getKthFromEnd(node1, 2).val); }} 时间复杂度：O(n)空间复杂度：O(1) 距离表示另一种解决此题的思路是：对链表进行一次完整遍历，拿到总长度cnt，cnt-k即是倒数第k个节点与head节点之间的距离 1234567891011public static ListNode getKthFromEnd(ListNode head, int k) { int cnt = 0; ListNode tmp = head; while (tmp != null) { tmp = tmp.next; cnt++; } cnt = cnt - k; while (cnt-- != 0) head = head.next; return head;} 时间复杂度：O(n)空间复杂度：O(1) 栈/队列：一个使用额外空间的解法是利用栈（队列），将所有的节点压入占中栈（队列）中，令当前栈（队列）容量为 cnt。 然后从栈顶（队列头）弹出 k 个（cnt - k + 1个）元素，最后一个出栈（出队列）的元素即是答案。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayDeque;import java.util.Deque;public class BottomK { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode getKthFromEnd(ListNode head, int k) { Deque&lt;ListNode&gt; d = new ArrayDeque&lt;&gt;(); while (head != null) { d.addLast(head); head = head.next; } ListNode ans = null; while (k-- &gt; 0) ans = d.pollLast(); return ans; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(getKthFromEnd(node1, 2).val); }} 时间复杂度：O(n)空间复杂度：O(n)","link":"/2022/08/02/Palindrome-Linked-List/"},{"title":"Merge Two Sorted Lists","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 12Input: list1 = [1,2,4], list2 = [1,3,4]Output: [1,1,2,3,4,4] 12Input: list1 = [], list2 = []Output: [] 12Input: list1 = [], list2 = [0]Output: [0] 来源：力扣（LeetCode） 循环+双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class mergeTwoSortedLists { public static class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode resultNode = new ListNode(0); ListNode p = resultNode; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) p.next = list1; if (list2 != null) p.next = list2; return resultNode.next; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(2); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(4); ListNode node6 = new ListNode(4); node1.next = node3; node3.next = node5; node2.next = node4; node4.next = node6; ListNode node = mergeTwoLists(node1, node2); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n+m)空间复杂度：O(1) 递归12345678910public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val &lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } list2.next = mergeTwoLists(list1, list2.next); return list2;} 时间复杂度：O(n+m)空间复杂度：O(n+m)","link":"/2022/08/04/Merge%20Two%20Sorted%20Lists/"},{"title":"Remove Duplicates from Sorted List","text":"Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 12Input: head = [1,1,2]Output: [1,2] 12Input: head = [1,1,2,3,3]Output: [1,2,3] 来源：力扣（LeetCode） 遍历链表：如果next和当前重复了，就把next指向next的next，否则当前指向next。 1234567891011121314151617181920212223242526272829303132333435363738394041public class duplicateRemoval { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode deleteDuplicates(ListNode head) { if (head == null) { return head; } ListNode currentNode = head; while (currentNode != null &amp;&amp; currentNode.next != null) { if (currentNode.next.val == currentNode.val) { currentNode.next = currentNode.next.next; } else { currentNode = currentNode.next; } } return head; } public static void main(String[] args) { ListNode node5 = new ListNode(3, null); ListNode node4 = new ListNode(3, node5); ListNode node3 = new ListNode(2, node4); ListNode node2 = new ListNode(1, node3); ListNode node1 = new ListNode(1, node2); ListNode node = deleteDuplicates(node1); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n) （每一个节点都要检查一次确定是否重复）空间复杂度：O(1) （没有使用额外空间） 双指针：12345678910111213141516public static ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head; while (pre != null) { if (pre.val != cur.val) { cur.next = pre; cur = cur.next; } pre = pre.next; } cur.next = null; return head;} 递归：1234567public static ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head;} 时间复杂度：O(n)","link":"/2022/07/31/Remove-Duplicates-from-Sorted-List/"},{"title":"Reverse Linked List","text":"Given the head of a singly linked list, reverse the list, and return the reversed list. 12Input: head = [1,2,3,4,5]Output: [5,4,3,2,1] 来源：力扣（LeetCode） 双指针迭代： 定义双指针：pre 和 cur 局部反转：cur.next=pre pre 和 cur 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 123456789101112131415161718192021222324252627282930313233343536373839404142public class reverseNode { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static void printList(ListNode head) { ListNode cur = head; while (cur != null) { System.out.printf(\"%d \", cur.val); cur = cur.next; } } public static void main(String[] args) { ListNode node5 = new ListNode(5, null); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); ListNode pre = reverseList(node1); printList(pre); }} 时间复杂度：O(n)空间复杂度：O(1) 双指针迭代：另一种思路，充分运用head头节点 12345678910111213public static ListNode reverseList(ListNode head) { if (head == null) { return null; } ListNode cur = head; while (head.next != null) { ListNode tmp = head.next.next; head.next.next = cur; cur = head.next; head.next = tmp; } return cur;} 时间复杂度：O(n)空间复杂度：O(1) 递归： 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789public static ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode cur = reverseList(head.next); head.next.next = head; head.next = null; return cur;} 时间复杂度：O(n)空间复杂度：O(n) 空间复杂度指的是执行算法需要的辅助存储空间相对于数据规模的增长关系，算的是变量的个数，对于递归程序，每递归一次都在栈上开辟一块内存，所以递归了多少次就开辟了多少块内存，开辟的那些内存就是空间复杂度，因为递归了n次，所以递归的空间复杂度为O(n)。","link":"/2022/07/29/Reverse%20Linked%20List/"},{"title":"Basic Concepts","text":"参考：高频问题总结 操作系统操作系统、进程管理、文件系统、内存IO模型 进程和线程的区别？ 进程是资源分配的最小单位，线程是任务执行，运算调度的最小单位，不能单独存在，包含在进程中。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 进程的调度算法有哪些？ 先来先服务调度 短作业优先调度 优先级调度 高响应比优先调度 时间片轮转调度 多级反馈队列调度 常用 IO 模型？关注消息通信机制: a) 同步：调用一个功能，在功能结果没有返回之前，一直等待结果返回。 b) 异步：调用一个功能，调用立刻返回，但调用者不能立刻得到结果。调用者可以继续后续的操作，其结果一般通过状态，回调函数来通知调用者。 等待调用结果时的状态： 阻塞：调用一个函数，当调用结果返回之前，当前线程会被挂起，只有得到结果之后才会返回。 非阻塞：调用一个函数，不能立刻得到结果之前，调用不能阻塞当前线程。一个输入操作通常包括两个阶段： 等待数据准备好 从内核向进程复制数据 对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。 阻塞 IO 模型：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。 非阻塞IO模型：进程发起 IO 系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。 IO 复用模型：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。（在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。） 信号驱动 IO 模型：当进程发起一个 IO 操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用 IO 读取数据。 异步 IO 模型：当进程发起一个 IO 操作，进程返回不阻塞，但也不能返回结果；内核把整个 IO 处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。","link":"/2022/08/30/Basic%20Concepts/"},{"title":"ClassLoader","text":"来源：ClassLoader in Java The&nbsp;Java ClassLoader&nbsp;is a part of the&nbsp;Java Runtime Environment&nbsp;that dynamically loads Java classes into the&nbsp;Java Virtual Machine. The Java run time system does not need to know about files and file systems because of classloaders. Java classes&nbsp;aren’t loaded into memory all at once, but when required by an application. At this point, the&nbsp;Java ClassLoader&nbsp;is called by the&nbsp;JRE&nbsp;and these ClassLoaders load classes into memory dynamically. Types of ClassLoaders in JavaNot all classes are loaded by a single ClassLoader. Depending on the type of class and the path of class, the ClassLoader that loads that particular class is decided. To know the ClassLoader that loads a class the&nbsp;getClassLoader()&nbsp;method is used. All classes are loaded based on their names and if any of these classes are not found then it returns a&nbsp;NoClassDefFoundError&nbsp;or&nbsp;ClassNotFoundException. A Java Classloader is of&nbsp;three types: BootStrap ClassLoader: &nbsp;A Bootstrap Classloader is a Machine code which kickstarts the operation when the JVM calls it. It is not a java class. Its job is to load the first pure Java ClassLoader. Bootstrap ClassLoader loads classes from the location&nbsp;rt.jar. Bootstrap ClassLoader doesn’t have any parent ClassLoaders. It is also called as the&nbsp;Primodial ClassLoader. Extension ClassLoader: &nbsp;The Extension ClassLoader is a child of Bootstrap ClassLoader and loads the extensions of core java classes from the respective JDK Extension library. It loads files from&nbsp;jre/lib/ext&nbsp;directory or any other directory pointed by the system property&nbsp;java.ext.dirs. System ClassLoader: &nbsp;An Application ClassLoader is also known as a System ClassLoader. It loads the Application type classes found in the environment variable&nbsp;CLASSPATH, -classpath or -cp command line option. The Application ClassLoader is a child class of Extension ClassLoader. Note: The ClassLoader Delegation Hierarchy Model always functions in the order Application ClassLoader-&gt;Extension ClassLoader-&gt;Bootstrap ClassLoader. The Bootstrap ClassLoader is always given the higher priority, next is Extension ClassLoader and then Application ClassLoader. Principles of functionality of a Java ClassLoader Principles of functionality are the set of rules or features on which a Java ClassLoader works. There are three principles of functionality, they are: Delegation Model: The Java Virtual Machine and the Java ClassLoader use an algorithm called the&nbsp;Delegation Hierarchy Algorithm&nbsp;to Load the classes into the Java file.The ClassLoader works based on a set of operations given by the delegation model. They are: ClassLoader always follows the&nbsp;Delegation Hierarchy Principle. Whenever JVM comes across a class, it checks whether that class is already loaded or not. If the Class is already loaded in the method area then the JVM proceeds with execution. If the class is not present in the method area then the JVM asks the Java ClassLoader Sub-System to load that particular class, then ClassLoader sub-system hands over the control to&nbsp;Application ClassLoader. Application ClassLoader then delegates the request to Extension ClassLoader and the&nbsp;Extension ClassLoader&nbsp;in turn delegates the request to&nbsp;Bootstrap ClassLoader. Bootstrap ClassLoader will search in the Bootstrap classpath(JDK/JRE/LIB). If the class is available then it is loaded, if not the request is delegated to Extension ClassLoader. Extension ClassLoader searches for the class in the Extension Classpath(JDK/JRE/LIB/EXT). If the class is available then it is loaded, if not the request is delegated to the Application ClassLoader. Application ClassLoader searches for the class in the Application Classpath. If the class is available then it is loaded, if not then a&nbsp;ClassNotFoundException&nbsp;exception is generated. Visibility Principle: The&nbsp;Visibility Principle&nbsp;states that a class loaded by a parent ClassLoader is visible to the child ClassLoaders but a class loaded by a child ClassLoader is not visible to the parent ClassLoaders. Suppose a class GEEKS.class has been loaded by the Extension ClassLoader, then that class is only visible to the Extension ClassLoader and Application ClassLoader but not to the Bootstrap ClassLoader. If that class is again tried to load using Bootstrap ClassLoader it gives an exception&nbsp;java.lang.ClassNotFoundException. Uniqueness Property: The&nbsp;Uniquesness Property&nbsp;ensures that the classes are unique and there is no repetition of classes. This also ensures that the classes loaded by parent classloaders are not loaded by the child classloaders. If the parent class loader isn’t able to find the class, only then the current instance would attempt to do so itself. Methods of Java.lang.ClassLoaderAfter the JVM requests for the class, a few steps are to be followed in order to load a class. The Classes are loaded as per the delegation model but there are a few important Methods or Functions that play a vital role in loading a Class. loadClass(String name, boolean resolve) : This method is used to load the classes which are referenced by the JVM. It takes the name of the class as a parameter. This is of type loadClass(String, boolean). defineClass() : The defineClass() method is a&nbsp;final&nbsp;method and cannot be overriden. This method is used to define a array of bytes as an instance of class. If the class is invalid then it throws&nbsp;ClassFormatError. findClass(String name) : This method is used to find a specified class. This method only finds but doesn’t load the class. findLoadedClass(String name) : This method is used to verify whether the Class referenced by the JVM was previously loaded or not. Class.forName(String name, boolean initialize, ClassLoader loader) : This method is used to load the class as well as initialize the class. This method also gives the option to choose any one of the ClassLoaders. If the ClassLoader parameter is NULL then Bootstrap ClassLoader is used. Example: &nbsp;The following code is executed before a class is loaded: 1234567891011121314151617181920protected synchronized Class&lt;?&gt;loadClass(String name, boolean resolve) throws ClassNotFoundException{ Class c = findLoadedClass(name); try { if (c == NULL) { if (parent != NULL) { c = parent.loadClass(name, false); } else { c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { System.out.println(e); } }} Note: If a class has already been loaded, it returns it. Otherwise, it delegates the search for the new class to the parent class loader. If the parent class loader doesn’t find the class,&nbsp;loadClass() &nbsp;calls the method&nbsp;findClass() &nbsp;to find and load the class. The&nbsp;findClass() &nbsp;method searches for the class in the current&nbsp;ClassLoader&nbsp;if the class wasn’t found by the parent&nbsp;ClassLoader.","link":"/2022/05/27/ClassLoader/"},{"title":"Binary Search Tree","text":"参考：二叉排序树 数组和链表对数据的存取 链表 数组 存取方式 只能顺序 顺序，随机 存储位置 不一定 逻辑上相邻的元素实际物理存储也相邻 存储空间 依赖指针，存储密度低 存储密度相对较高 按值查找 O(n) 无序：O(n)；有序，折半查找O(logn) 索引查找 不支持随机访问，O(n) 可以随机访问，O(1) 插入删除 修改指针即可 平均需要移动$n/2$个元素 空间分配 按需申请，内存有空间即可分配 静态，存储元素数量受限；动态，虽然存储空间可以扩充，需要移动大量元素，操作效率低，如果内存没有更大的连续存储空间，分配失败 利用树来存取，既可以保证数据的检索，同时也可以保证数据的插入，删除，修改的速度。 Given preorder traversal of a binary search tree, construct the BST. For example, if the given traversal is {10, 5, 1, 7, 40, 50}, then the output should be the root of the following tree. 12345 10 / \\ 5 40 / \\ \\1 7 50 Method 1time complexity: $O(n^2)$ The first element of preorder traversal is always root. We first construct the root. Then we find the index of the first element which is greater than the root. Let the index be ‘i’. The values between root and ‘i’ will be part of the left subtree, and the values between ‘i’(inclusive) and ‘n-1’ will be part of the right subtree. Divide given pre[] at index “i” and recur for left and right sub-trees. In {10, 5, 1, 7, 40, 50}, 10 is the first element, so we make it root. Now we look for the first element greater than 10, we find 40. So we know the structure of BST is as following. 1234 10 / \\ / \\{5, 1, 7} {40, 50} We recursively follow above steps for subarrays {5, 1, 7} and {40, 50}, and get the complete tree. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Java program to construct BST from given preorder// traversal// A binary tree nodeclass Node { int data; Node left, right; Node(int d) { data = d; left = right = null; }}class Index { int index = 0;}class BinaryTree { Index index = new Index(); // A recursive function to construct Full from pre[]. // preIndex is used to keep track of index in pre[]. Node constructTreeUtil(int pre[], Index preIndex, int low, int high, int size) { // Base case if (preIndex.index &gt;= size || low &gt; high) { return null; } // The first node in preorder traversal is root. So // take the node at preIndex from pre[] and make it // root, and increment preIndex Node root = new Node(pre[preIndex.index]); preIndex.index = preIndex.index + 1; // If the current subarray has only one element, no // need to recur if (low == high) { return root; } // Search for the first element greater than root int i; for (i = low; i &lt;= high; ++i) { if (pre[i] &gt; root.data) { break; } } // Use the index of element found in preorder to // divide preorder array in two parts. Left subtree // and right subtree root.left = constructTreeUtil( pre, preIndex, preIndex.index, i - 1, size); root.right = constructTreeUtil(pre, preIndex, i, high, size); return root; } // The main function to construct BST from given // preorder traversal. This function mainly uses // constructTreeUtil() Node constructTree(int pre[], int size) { return constructTreeUtil(pre, index, 0, size - 1, size); } // A utility function to print inorder traversal of a // Binary Tree void printInorder(Node node) { if (node == null) { return; } printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } // Driver code public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int pre[] = new int[] { 10, 5, 1, 7, 40, 50 }; int size = pre.length; Node root = tree.constructTree(pre, size); System.out.println( \"Inorder traversal of the constructed tree is \"); tree.printInorder(root); }} Method 2time complexity: $O(n)$ The trick is to set a range {min .. max} for every node. Initialize the range as {INT_MIN .. INT_MAX}. The first node will definitely be in range, so create a root node. To construct the left subtree, set the range as {INT_MIN …root-&gt;data}. If a value is in the range {INT_MIN .. root-&gt;data}, the values are part of the left subtree. To construct the right subtree, set the range as {root-&gt;data..max .. INT_MAX}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// Java program to construct BST from given preorder// traversal// A binary tree nodeclass Node { int data; Node left, right; Node(int d) { data = d; left = right = null; }}class Index { int index = 0;}class BinaryTree { Index index = new Index(); // A recursive function to construct BST from pre[]. // preIndex is used to keep track of index in pre[]. Node constructTreeUtil(int pre[], Index preIndex, int key, int min, int max, int size) { // Base case if (preIndex.index &gt;= size) { return null; } Node root = null; // If current element of pre[] is in range, then // only it is part of current subtree if (key &gt; min &amp;&amp; key &lt; max) { // Allocate memory for root of this // subtree and increment *preIndex root = new Node(key); preIndex.index = preIndex.index + 1; if (preIndex.index &lt; size) { // Construct the subtree under root // All nodes which are in range {min .. key} // will go in left subtree, and first such // node will be root of left subtree. root.left = constructTreeUtil( pre, preIndex, pre[preIndex.index], min, key, size); } if (preIndex.index &lt; size) { // All nodes which are in range {key..max} // will go in right subtree, and first such // node will be root of right subtree. root.right = constructTreeUtil( pre, preIndex, pre[preIndex.index], key, max, size); } } return root; } // The main function to construct BST from given // preorder traversal. This function mainly uses // constructTreeUtil() Node constructTree(int pre[], int size) { int preIndex = 0; return constructTreeUtil(pre, index, pre[0], Integer.MIN_VALUE, Integer.MAX_VALUE, size); } // A utility function to print inorder traversal of a // Binary Tree void printInorder(Node node) { if (node == null) { return; } printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } // Driver code public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int pre[] = new int[] { 10, 5, 1, 7, 40, 50 }; int size = pre.length; // Function call Node root = tree.constructTree(pre, size); System.out.println( \"Inorder traversal of the constructed tree is \"); tree.printInorder(root); }}","link":"/2022/09/01/Binary-Search-Tree/"},{"title":"Simon Speaking","text":"参考：Simon Speaking Part 1It’s just like a warm up to get started, the questions will be short, fast, easy and your answers should be as well so just give short simple answers and remember you cannot get a score from part 1.So if you want to get high score, you should be worrying more about parts 2 and 3, just get through part 1 with short simple answers without too many hesitations and then we can worry about language when we study parts 2 and 3. Tips: answer the question then give a reason try to answer with a full sentence may be 2 sentences that’s all","link":"/2022/09/03/Simon-Speaking/"},{"title":"Basic AI Revision","text":"人工智能有那些学派？它们的认知观有哪些？ 符号主义（逻辑主义、心理学派、计算机学派）其原理主要为物理符号系统假设和有限合理性原理。符号主义认为人工智能源于数理逻辑。 连接主义（仿生学派、生理学派）主要为神经网络及其间的连接机制和学习算法。连接主义认为人工智能源于仿生学，特别是人脑模型的研究。 行为主义（进化主义、控制论学派）主要为控制论及感知-动作型控制系统。行为主义认为人工智能源于控制论。 What schools of thought are there in artificial intelligence? What are their cognitive views? Symbolism (logical, psychological, and computer schools) is based on the assumption of physical symbolic systems and the principle of finite rationality. Symbolism believes that artificial intelligence has its roots in mathematical logic. Connectionism (bionic school, physiological school) focuses on neural networks and their interconnection mechanisms and learning algorithms. Connectionism believes that artificial intelligence originates from bionics, especially the study of human brain models. Behaviorism (evolutionism, cybernetics school) is mainly cybernetics and perception-action type control systems. Behaviorism argues that artificial intelligence originates from cybernetics. 人工智能包含哪些要素？各要素在人工智能中的作用是什么？包含要素：知识，数据，算法，算力，人才 知识：人工智能源于知识，依赖知识；知识是人工智能的重要基础，专家系统，模糊计算等知识工程都是以知识为基础而发展起来的。 数据：数据是人工智能之基础；神经计算，进化计算等计算智能都是以数据为基础而发展起来的。 算法: 算法是人工智能之魂，是解题方案准确而完整的描述，是一系列求解问题的精准指令。 算力：算力是人工智能之力。算力就是计算能力，机器在数学上的归纳和转化能力。计算能力不断提高，极大促进了人工智能的发展，特别是人工智能产业的蓬勃发展。 人才：人工智能的要素和核心技术要通过人发挥作用，发展人工智能的关键是人才。培养足够多的各层次高素质人工智能人才，才能保证人工智能的顺利发展。 What elements are included in artificial intelligence? What is the role of each element in artificial intelligence? Elements: knowledge, data, algorithm, arithmetic, talent Knowledge: Artificial intelligence originates from and relies on knowledge; knowledge is the important foundation of artificial intelligence, expert systems, fuzzy computing and other knowledge engineering are developed based on knowledge. Data: Data is the basis of AI; neural computing, evolutionary computing and other computational intelligence are developed on the basis of data. Algorithm: Algorithm is the soul of artificial intelligence, an accurate and complete description of the solution, a series of precise instructions for solving the problem. Arithmetic: Arithmetic is the power of artificial intelligence. Arithmetic is computational power, the ability of a machine to generalize and transform mathematically. The continuous improvement of computing power has greatly contributed to the development of artificial intelligence, especially the flourishing of the artificial intelligence industry. Talent: The elements and core technologies of artificial intelligence have to function through people, and the key to developing AI is talent. Cultivating enough high-quality artificial intelligence talents at all levels can ensure the smooth development of AI. 人工智能的研究目标？一般研究目标 更好地理解人类智能，通过编写程序来模仿和检验有关人类智能的理论 创造有用的灵巧程序，该程序能够执行一般需要人类专家才能实现的任务 还有一种分类 近期研究目标：建造智能计算机以代替人类的某些智力活动。主要研究依赖于现有的计算机去模拟人类某些智力行为的基本理论、基本方法。 远期研究目标：探讨智能的基本机理，用自动机模仿人类的思维活动和智力功能。其中，最终目标（从研究内容出发)指的是理解人类的认识、有效的自动化、有效的智能拓展、超人的智力、通用问题求解、连贯性交谈、自治、学习、储存信息。 Research goals for artificial intelligence? General research objectives To better understand human intelligence by writing programs to mimic and test theories about human intelligence Create useful dexterous programs that are capable of performing tasks that would normally require a human expert to achieve Another classification Recent research goal: to build intelligent computers to replace certain intellectual activities of human beings. The main research focuses on the basic theory and basic methods of relying on existing computers to simulate certain intellectual behaviors of humans. Long-term research goal: to explore the basic mechanism of intelligence and to imitate human thinking activities and intellectual functions with automata. Among them, the ultimate goals (from the research content) refer to understanding human cognition, effective automation, effective intelligence expansion, superhuman intelligence, generic problem solving, coherent conversation, autonomy, learning, and storage of information. 人工智能包含哪些内容？ 认知建模：说明人类在认知过程中是如何进行加工的 知识表示：运用符号知识、算法和状态图来描述问题 知识推理：从已知判断推导出一个新的判断或结论的过程 计算智能：涉及神经计算、模糊计算、自然计算、蚁群计算等领域 知识应用：侧重于人工智能的学习在各领域的应用能力 机器感知：使机器具有类似于人的感觉，包括视觉、听觉、嗅觉、力觉 机器思维：对传感器和机器内部的工作信息进行有目的处理 机器学习：使机器具有学习新知识和能力 机器行为：智能系统具有表达和行动能力，如对话，描写，行走 智能系统构建：开展对模型、系统构造等的构建研究 What does artificial intelligence involve? Cognitive modeling: describing how humans process during cognition Knowledge representation: the use of symbolic knowledge, algorithms, and state diagrams to describe problems Intellectual reasoning: the process of deriving a new judgment or conclusion from a known judgment Computational Intelligence: involves the fields of neural computing, fuzzy computing, natural computing, ant colony computing, etc. Knowledge application: focuses on the ability to apply the learning of artificial intelligence in various fields Machine perception: making machines with human-like senses, including vision, hearing, smell, and force senses Machine Thinking: Purposeful processing of sensors and information about the inner workings of the machine Machine learning: enabling machines to have the ability to learn new knowledge and capabilities Machine behavior: intelligent systems with the ability to express and act, such as dialogue, portray, walk Intelligent system construction: conduct research on the construction of models, system constructs, etc. 什么是状态空间表示法？要点有哪些？完成某个问题的状态描述必须确定哪三件事？什么是状态空间表示法？ 状态空间state space是利用状态变量和操作符表示系统或问题的有关知识的符号体系。其中状态是为描述某类不同类事物间差别而引入的一组最少变量的有序集合，操作符（算符）是使问题从一种状态变化到另一种状态的手段。 要点有哪些？ (S,F,G)S:初始状态集合F:操作符集合G:终止状态集合 需要确定的三件事 该状态的描述方式，特别是初始状态的描述 操作符集合及其对状态描述的作用 目标状态描述的特性 What is a state space representation? Main points? What three things must be determined to complete a state description of a particular problem? What is a state space representation? The state space state space is a symbolic system that uses state variables and operators to represent the relevant knowledge of a system or problem. Where a state is an ordered set of a minimum number of variables introduced to describe the difference between different classes of things of a certain type, and an operator (operator) is a means to change a problem from one state to another. Main points? (S,F,G)S:the set of possible initial statesF:set of operatorsG:the set of target states Three things that need to be determined The way this state is described, especially the initial state The set of operators and their role for the state description The properties of the target state description 问题规约表示法的要点是什么？组成部分是什么？3、4层的汉诺塔问题如何解决？问题规约是另一种基于状态空间的问题描述与求解方法。已知问题的描述，从目标出发逆向推理，建立子问题以及子问题的子问题，直至最后把初始问题规约成一个平凡的本原问题集合。 组成部分 一个初始问题描述 一套把问题转化成子问题的操作符 一套本原问题描述 汉诺塔问题的解决 首先对于3层汉诺塔，由于目标是将所有盘子从1移至3柱，首先需要将C移至3柱，并且下面没有其它盘，所以AB盘需要先移动至2柱，等C到3柱后，再移至3柱，因此可以分为如下3个子问题 AB移动至2柱双圆盘难题 C移动至3柱单元盘难题 AB移动至3柱双圆盘难题 对于4层汉诺塔，同理 What are the main points of the problem statute representation? What are the components and how are the 3 and 4 level Hannota problems solved? The problem statute is another state space-based method for describing and solving problems. The description of the problem is known, reasoning backwards from the objective, building subproblems and subproblems of subproblems, until finally the initial problem is statuted into a mundane set of original problems. Component An initial problem description A set of operators for transforming the problem into subproblems A set of intrinsic problem descriptions A solution to the Hannota problem First of all for the 3 layer Hannota, since the goal is to move all discs from 1 to 3 column, first you need to move C to 3 column, and there are no other discs below, so AB disc needs to be moved to 2 column first, and then to 3 column after C gets to 3 column, so it can be divided into 3 subproblems as follows AB move to 2 column double disc problem C moves to the 3 column unit disk problem AB moves to the 3 column double disc problem For the 4-layer Hanno tower, the same 谓词逻辑表示，什么是连词？什么是量词？谓词逻辑的基本组成部分是谓词符号、变量符号、函数符号和常量符号，并用一些符号隔开，以表示论域内的关系。一般，原子公式由谓词符号和项组成，常量符号是最简单的项，用来表示论域内的物体或实体，变量符号也是项，不必明确涉及是哪一个实体，函数符号表示论域内的函数。 连词 ∧与（析取）、∨或（合取）、→蕴涵、¬否定 量词 ∀全称量词，表示“所有的”或“每一个”∃存在量词，表示“存在某个”或“至少有一个” 量词的辖域 位于量词后面的单个谓词或者用括弧括起来的谓词公式。辖域内与量词中同名的变元称为约束变元，不同名的变元称为自由变元。 例如： (∃X)(P(X,Y) → Q(X,Y)) ∨ R(X,Y)(∃X)的辖域：(P(X,Y) → Q(X,Y)) 该辖域内的X是约束变元，而在R(X,Y)中的X则是自由变元，例子中的所有Y都是自由变元。 Predicate logical representation, what is a conjunction? What is a quantifier? The basic components of predicate logic are predicate symbols, variable symbols, function symbols, and constant symbols, separated by some symbols to represent relationships within the domain of the argument. In general, atomic formulas consist of predicate symbols and terms, constant symbols are the simplest terms used to represent objects or entities in the domain of the argument, variable symbols are also terms and do not have to explicitly involve which entity they are, and function symbols represent functions in the domain of the argument. The conjunction ∧ with (parse), ∨ or (combine), → implication, ¬ negation Quantifiers ∀ full quantifier for “all” or “every”∃ existential quantifier, indicating “there is a certain” or “at least one” Scope of a quantifier A single predicate located after the quantifier or a predicate formula enclosed in parentheses. Variants in the domain with the same name as in the quantifier are called bound variants, and variants with different names are called free variants. For example (∃X)(P(X,Y) → Q(X,Y)) ∨ R(X,Y)Jurisdiction of (∃X): (P(X,Y) → Q(X,Y)) X in this jurisdiction is a bounded variant, while X in R(X,Y) is a free variant, as well as all Y in example. 谓词公式？在谓词演算中，何是其递归定义？谓词公式 用P(x1,x2,...,xn)表示一个n元谓词公式，其中P为n元谓词，x1...xn为客体变量或变元，通常把P(x1,x2,...,xn)叫做谓词演算的原子公式（原子谓词公式），可以用连词把谓词公式组成复合谓词公式，称为分子谓词公式。 递归定义 单个谓词，称为原子谓词公式 若A是谓词公式，则¬ A 也是谓词公式 若A、B都是谓词公式，则A ∧ B 、A ∨ B 、A → B、A ←→ B 也都是谓词公式 若A是谓词公式，则( ∀ X ) A、( ∃ X ) A 也都是谓词公式 有限应用上述步骤所得到的公式也是谓词公式 连接词的优先级别从高到低排列：¬,∧,∨,→ Predicate formula? What is its recursive definition in the predicate algorithm? The predicate formula Denote by P(x1,x2,... ,xn) to denote an n elementary predicate formula, where P is the n elementary predicate and x1.. .xn are the object variables or variables, and usually P(x1,x2,... ,xn) is called the atomic formula for predicate evaluation (atomic predicate formula), and the predicate formula can be formed into a compound predicate formula by concatenating the predicate formula, called the molecular predicate formula. Recursive definition* A single predicate, called an atomic predicate formula If A is a predicate formula, then ¬ A is also a predicate formula If A and B are predicate formulas, then A ∧ B, A ∨ B, A → B, A ←→ B are also predicate formulas If A is a predicate formula, then ( ∀ X ) A, ( ∃ X ) A are also predicate formulas The formulas obtained by finite application of the above steps are also predicate formulas The conjunctions are ranked from highest to lowest priority: ¬,∧,∨,→ 谓词演算公式转化为子句集的一般步骤？（例子）例如(∀X)((∀y)P(x,y)→¬(∀y)(Q(x,y)→R(x,y))) 消去蕴含和等价，(∀X)(¬(∀y)P(x,y)∨¬(∀y)(¬Q(x,y)∨R(x,y))) 移动否定符号仅靠谓词，(∀X)((∃y)¬P(x,y)∨(∃y)¬(¬Q(x,y)∨R(x,y)))再利用谓词公式的等价关系(∀X)((∃y)¬P(x,y)∨(∃y)(Q(x,y)∧¬R(x,y))) 变量标准化，使每个量词（不同量词的约束变元）采用不同的变元，(∀X)((∃y)¬P(x,y)∨(∃z)(Q(x,z)∧¬R(x,z))) 消去存在量词，(∀X)(¬P(x,f(x))∨(Q(x,g(x))∧¬R(x,g(x)))) 化为前束形，所有的全称量词提前，由于例子只有一个全称量词且在串首无需改动 化为Skolem标准型，(∀X)((¬P(x,f(x))∨Q(x,g(x))∧(¬P(x,f(x)∨¬R(x,g(x)))) 略去全称量词，(¬P(x,f(x))∨Q(x,g(x))∧(¬P(x,f(x)∨¬R(x,g(x))) 消去合取词，把母式用子句集表示，¬P(x,f(x))∨Q(x,g(x)、¬P(x,f(x)∨¬R(x,g(x)) 子句变量标准化，¬P(x,f(x))∨Q(x,g(x)、¬P(y,f(y)∨¬R(y,g(y)) 来自AI：谓词公式化为子句集 General steps for converting predicate algorithm formulas to clause sets? (example) For example (∀X)((∀y)P(x,y)→¬(∀y)(Q(x,y)→R(x,y))) Eliminate implication and equivalence, (∀X)(¬(∀y)P(x,y)∨¬(∀y)(¬Q(x,y)∨R(x,y)) Move the negation symbols by predicates only, (∀X)((∃y)¬P(x,y)∨(∃y)¬(¬Q(x,y)∨R(x,y)) and then use the equivalence relation of the predicate formula (∀X)((∃y)¬P(x,y)∨(∃y)(Q(x,y)∧¬R(x,y))) Normalize the variables so that each quantifier (constraint variant of different quantifiers) uses a different variant, (∀X)((∃y)¬P(x,y)∨(∃z)(Q(x,z)∧¬R(x,z))) Eliminate the existence quantifier, (∀X)(¬P(x,f(x))∨(Q(x,g(x))∧¬R(x,g(x)))) into prebundle form with all holomorphemes advanced, since the example has only one holomorpheme and no change is needed at the beginning of the string into Skolem standard form, (∀X)((¬P(x,f(x))∨Q(x,g(x))∧(¬P(x,f(x)∨¬R(x,g(x)))) omit the full quantifier, (¬P(x,f(x))∨Q(x,g(x))∧(¬P(x,f(x)∨¬R(x,g(x))) Eliminate the cofetcher and represent the parent formula as a set of clauses, ¬P(x,f(x))∨Q(x,g(x), ¬P(x,f(x)∨¬R(x,g(x)) Clause variable normalization, ¬P(x,f(x))∨Q(x,g(x), ¬P(y,f(y)∨¬R(y,g(y)) From AI: Predicate Formulation as a Subset of Clauses 图搜索算法的一般过程？ 建立一个只含有起始节点S的搜索图G，把S放到一个OPEN表中 初始化CLOSED表为空表 LOOP，若OPEN表为空表，则失败退出 选择OPEN表上的第一个节点，把它从OPEN表中移出并放入到CLOSED表中，称此节点为节点n 若n为目标节点，则说明有解并成功退出 扩展节点n，生成后继节点集合M 对于那些未曾在G中出现过的（既不在OPEN也不在CLOSED表中）M成员设置其父节点指针指向n并加入OPEN表，对已经在OPEN或CLOSED表中出现过的每一个M成员，确定是否需要将原来的父节点更改为n。对于已经在CLOSED表上的每个M成员，若修改了其父节点，则将该节点从CLOSED表中移出，重新加入到OPEN表中。 按某一任意方式或按某个测试值，重排OPEN表 GO LOOP General procedure of graph search algorithm? Create a search graph G containing only the starting node S, put S into an OPEN table Initialize the CLOSED table to be empty LOOP, if the OPEN table is empty, then fail to exit Select the first node on the OPEN table, move it out of the OPEN table and put it into the CLOSED table, call this node node n If n is the target node, then the solution is available and exit successfully Expand node n to generate the set of successor nodes M For those M members that have not appeared in G (neither in the OPEN nor CLOSED tables) set their parent node pointer to n and add them to the OPEN table, and for each M member that has already appeared in the OPEN or CLOSED tables, determine whether the original parent node needs to be changed to n. For each M member already in the CLOSED table whose parent node is modified, remove the node from the CLOSED table and rejoin it in the OPEN table. Reorder the OPEN table according to some arbitrary method or some test value GO LOOP 启发式搜索如何定义？策略？启发函数？估价函数？（了解）如何定义？ 启发式搜索informed search是一条引导你进入最佳选择的规则，它决定了状态空间中一个状态的质量，引导你每次都选择质量最好（或较好）的状态，一步步走向最佳方案。通过一个估价函数来表示f(n) = g(n) + h(n)，其中g(n)表示从初始节点到当前节点所需的开销，h(n)表示从当前节点到目标节点还剩的差距。 策略？ 有关具体问题领域的信息常常可以用来简化搜索。假设初始状态﹑算符和目标状态的定义都是完全确定的,然后决定一个搜索空间。此问题关键在于如何有效地搜索这个给定空间。进行这种搜索的技术一般需要某些有关具体问题领域的特性的信息。已把此种信息叫做启发信息,并把利用启发信息的搜索方法叫做启发式搜索方法。 启发函数？ 启发函数是一种函数用来估算当前state和目标state之间的距离，用于路径决策。在A*算法里：估价函数：f(n) = g(n) + h(n)。其中h(n)就是启发函数。 估价函数？ 应用某些准则来重新排列每一步OPEN表中所有节点的顺序。然后，搜索就可能沿着某个被认为是最有希望的边缘区段向外扩展。估价函数的值越小，意味着该节点位于最优解路径上的“希望”越大，最后找到的最优路径即平均综合指标为最小的路径。 How is heuristic search defined? Strategy? Heuristic function? Valuation function? (Understand) How to define? A heuristic search informed search is a rule that guides you to the best choice, which determines the quality of a state in the state space and guides you to the best (or better) quality state each time, step by step towards the best solution. It is represented by an estimation function f(n) = g(n) + h(n), where g(n) represents the overhead required to get from the initial node to the current node and h(n) represents the gap left from the current node to the target node. Strategy? Information about a specific problem domain can often be used to simplify the search. Assume that the initial state, operator and target state are completely defined, and then decide on a search space.The key to the problem is how to efficiently search this given space. The technique of performing such a search generally requires some information about the properties of the specific problem domain. Such information is called heuristic information, and search methods that use heuristic information are called heuristic search methods. Heuristic functions? A heuristic function is a function used to estimate the distance between the current state and the target state for path decision. In the A* algorithm: estimation function: f(n) = g(n) + h(n). Where h(n) is the heuristic function. The valuation function? Some criterion is applied to rearrange the order of all nodes in the OPEN table at each step. The search may then be extended outward along some edge segment that is considered to be the most promising. The smaller the value of the valuation function, the more “promising” the node is on the optimal solution path, and the final optimal path found is the path with the smallest average composite index. A*算法？（了解）一个特别的估价函数f(n)，估算出从开始节点到n和节点n到目标节点的最小带权路径的代价之和 以下所提及的路径均为带权路径 定义 k(n,m)表示从节点n到m之间的最小路径的代价，m和n必须是连通的。 h*(n)表示n到整个目标节点集合的所有中最小路径的一个，也就是说h*(n)是n到目标节点的最小代价 g*(n)=k(S,n) 表示从开始节点到节点n的最小路径的代价 f*(n)=g*(n)+h*(n) 表示从开始节点通过节点n到目标节点的最小路径的代价 估价函数f(n)=g(n)+h(n)是f*(n)的一个估计。其中h是h*的估计，g是g*的估计，h依赖于启发的信息，我们称h为启发函数。 步骤 1）把S放入OPEN表中,记f=h,令CLOSED为空表.2）若OPEN表为空,失败退出.3）在OPEN表中选取有最小f值的节点为best,并将它放入CLOSED表.4）若best节点是目标节点,则成功退出.5）best节点不是目标节点,则把best节点扩展,产生后续节点children.6）对于每个children进行如下的操作: 建立值相父节点的指针 计算g(children)=g(best)+g(best,children) 如果children在OPEN表中,比较新旧路径,如果小于就把原来节点的父节点改为best并用新的代价取代原来的代价. 如果节点在CLOSED表中,转向c 如果节点即不在OPEN表中也不在CLOSED表中,则加入表OPEN中.7）计算f值8）GOTO 2 A-star algorithm? (Understanding) A special valuation function, f(n), estimates the sum of the costs of the minimum weighted paths from the start node to n and from node n to the target node The paths mentioned below are all weighted paths Define k(n,m) denotes the cost of the minimum path from node n to m. m and n must be connected. h*(n) denotes one of all the smallest paths from n to the whole set of target nodes, that is, h*(n) is the smallest cost from n to the target node g*(n)=k(S,n) denotes the cost of the smallest path from the start node to node n f*(n)=g*(n)+h*(n) denotes the cost of the minimum path from the start node to the target node through node n The valuation function f(n)=g(n)+h(n) is an estimate of f*(n). where h is an estimate of h*, g is an estimate of g*, h depends on the inspired information, and we call h the inspired function. Step Put S into the OPEN table, note f=h, and let CLOSED be the empty table.(2) If OPEN table is empty, fail to exit.(3) in the OPEN table to select the node with the minimum f value of best, and put it into the CLOSED table. If the best node is the target node, then exit successfully. If the best node is not the target node, then extend the best node to produce subsequent children. For each child, perform the following operations: create a pointer to the value of the parent node calculate g(children)=g(best)+g(best,children) if children is in the OPEN table, compare the old and new paths, if it is smaller than the original node’s parent node to best and replace the original cost with the new cost. if the node is in the CLOSED table, turn to c if the node is not in the OPEN table nor in the CLOSED table, then add it to the OPEN table. Calculate the value of f GOTO 2 人工神经网络的基本结构？人工神经网络的主要学习算法？（宏观）人工神经网络由神经元模型构成，这种由许多神经元组成的信息处理网络具有并行分布结构。每个神经元具有单一输出，并且能够与其它神经元连接，存在许多输出连接方法，每种连接方法对应于一个连接权系数。基本结构是三层，输入层，隐层，输出层，各层由神经元和神经元之间的权值组成。基本结构分为以下两类： 递归网络，多个神经元互连组成一个互连的神经网络 前馈网络，同层神经元间不存在互连，从输入层至输出层的信号单向流通 三种学习算法 有师学习，能根据期望和实际网络输出之间的差来调整神经元间连接的强度或权值，期望（目标输出信号）由“导师”提供。 无师学习，不需要知道期望输出，在训练过程中，只要向神经网络提供输入模式，神经网络就能自动地适应连接权值，以便按照相似特征把输入模式分组聚集。 增强学习，其实是有师学习的特例，但是并不需要提供期望（目标输出），需要一个“导师”来评价与给定输入相对应的神经网络输出的优度。遗传算法正是增强学习的一个例子。 Basic structure of artificial neural network? Main learning algorithms of artificial neural networks? (Macro) Artificial neural networks consist of a neuronal model, an information processing network composed of many neurons with a parallel distribution structure. Each neuron has a single output and can be connected to other neurons, and there are many output connection methods, each corresponding to a connection weight coefficient. The basic structure is three layers, input layer, hidden layer, and output layer, and each layer consists of neurons and weights between neurons. The basic structures are divided into two categories. Recurrent networks, where multiple neurons are interconnected to form an interconnected neural network feedforward networks, where there is no interconnection between neurons in the same layer and the signal flows unidirectionally from the input layer to the output layer Three learning algorithms Learning with a mentor, which adjusts the strength or weights of the connections between neurons based on the difference between the expectation and the actual network output, with the expectation (the target output signal) provided by the “mentor”. Masterless learning, which does not require knowledge of the desired output, simply provides the neural network with input patterns during training, and the neural network automatically adapts the connection weights so that the input patterns are grouped and aggregated according to similar characteristics. Augmented learning, in fact, is a special case of teacher learning, but does not require the provision of expectations (target outputs) and requires a “mentor” to evaluate the superiority of the output of the neural network with respect to the given inputs. Genetic algorithms are an example of augmented learning. 遗传算法的基本原理？求解过程？遗传算法是模仿生物遗传学和自然选择机理，通过人工方式构造的一类优化搜索算法，是对生物进化过程进行的一种数学仿真，是进化计算的一种最重要的形式。 初始化：设置进化代数计数器t=0，设置最大进化代数T，随机生成M个个体作为初始群体P(0)。 个体评价：计算群体P(t)中各个个体的适应度。 选择运算:将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。 交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。 变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。 终止条件判断:若t=T,则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。 The basic principle of genetic algorithm? Solution process? Genetic algorithm is a class of optimization search algorithm constructed artificially by imitating biological genetics and natural selection mechanism, which is a mathematical simulation of biological evolution process and one of the most important forms of evolutionary computation. Initialization: set the evolutionary algebra counter t=0, set the maximum evolutionary algebra T, and randomly generate M individuals as the initial population P(0). Individual evaluation:Calculate the fitness of each individual in the population P(t). Selection operation:The selection operator is applied to the population. The purpose of selection is to pass on optimized individuals directly to the next generation or to generate new individuals by pairwise crossover and then pass them on to the next generation. The selection operation is based on the fitness assessment of the individuals in the population. Crossover operation: the crossover operator is applied to the population. The crossover operator plays a central role in genetic algorithms. Variation operation: The variation operator is applied to the population. This means that the value of a gene in some locus of a string of individuals in the population is changed.The population P(t) is selected, crossed and mutated to obtain the next generation population P(t+1). Termination condition judgment: If t=T, then the individual with the maximum fitness obtained during the evolutionary process is output as the optimal solution and the calculation is terminated. 决策树的一般过程？最优属性选择划分的三种方法？决策树由一系列节点和分支组成，在节点和子节点之间形成分支，节点代表决策或学习过程中所考虑的属性，不同属性形成不同分支。为了使用决策树对某一实例进行学习，做出决策，可以利用该实例的属性值由决策树的根节点向下搜索，直到叶节点为止，此叶节点即包含学习或决策结果。 如何根据测试对象的属性来决定划分，决策树自上而下，其中每个节点都有一个属性被测试，测试结果用来划分对象集。反复进行这一过程直至某一子树中的集合与分类标准为同类为止，这个集合就是叶节点。决策树有ID3、C4.5、CART三种流行的特征选择的方法，其中ID3使用的标准是信息增益，C4.5使用的是信息增益比，CART使用的是基尼系数，三者中仅有CART树不仅可以做分类问题，还可以做回归问题。 The general process of decision tree? Three methods of optimal attribute selection division? A decision tree consists of a series of nodes and branches that form branches between nodes and children, where the nodes represent attributes considered in the decision making or learning process, and different attributes form different branches. In order to use the decision tree to learn and make a decision about an instance, you can use the attribute values of the instance to search from the root node of the decision tree down to the leaf node, which contains the learning or decision results. How the division is decided based on the attributes of the tested objects, the decision tree is top-down, where each node has an attribute tested and the test result is used to divide the set of objects. This process is repeated until the set in a certain subtree is of the same kind as the classification criteria, and this set is the leaf node. There are three popular methods of feature selection, ID3, C4.5 and CART, among which ID3 uses the criterion of information gain, C4.5 uses the information gain ratio and CART uses the Gini coefficient, among the three only the CART tree can do not only classification problems but also regression problems. 专家系统的组成部分？开发步骤？（基本不考）专家系统 人机交互界面 知识库 数据库 推理机 解释器 知识获取 开发步骤 知识工程师首先通过与专家进行对话获取专家知识。 将知识编码至知识库中 专家评估系统并返回意见给知识工程师 循环直至系统性能为专家所满意。 Components of an expert system? Development steps? (basically not tested) Expert System Human-computer interaction interface Knowledge base Database Reasoning machines Interpreter Knowledge Acquisition Development Steps The knowledge engineer first acquires expert knowledge by having a conversation with an expert. Encode the knowledge into the knowledge base The expert evaluates the system and returns comments to the knowledge engineer Loop until the system performs to the expert’s satisfaction","link":"/2022/05/21/Basic-AI-Revision/"},{"title":"MY IELTS ROADS","text":"Vocabulary English Chinese concession/yield/compromise 让步 venue 地点，场馆 sophisticated 复杂的，精密的 intricate 错综复杂的 daunt 气馁 intrinsic 本质的，固有的 instinct 天性，直觉 enquiring 爱打听的，询问 confine 边界 refine 精炼 define 定义 definite 确定的，有把握的 infinite 无限的 stunt 噱头，阻碍…的正常生长 outset 开端 conveyable/portable 便携的 down payment 首付 advanced payment 提前付款 prompt payment 立即付款 installment 分期付款 deduction 演绎，推理，扣除 perspective 前景，角度，透视 coined/be coined by/first use/invent 创造（首次） emigration 移民（出） immigration 移民（入） post-war/after the war 战后（postgraduate） across the social spectrum 社会各界 universality 普遍性 (group)setting/environment 环境 submissive 顺从的 energising 充满活力的 facilitate 促进 traditional view/established notions 传统观点 accomplishment/achievement 成就 deposit 押金 dispose 处置 restless 焦躁不安的 conductive 能传导的 unconsciousness 神智不清的 frantic 手足无措的 persevere 持之以恒 people throughout the country 全国人民 fiscal/financial 财政的/金融的 envisage/conceive 构想，设想 entail 牵涉，使必要 feat 壮举，技艺 impetus/incentive 动力，促进 overhaul 检修，改造 amend/rectify/change/modify/revise/alter 修改/改变 adversity/plight 困境 diverse species 多物种 prosper/thrive 繁荣 thrift 节约 shatter/scatter 分散/粉碎 allege/proclaim/assert 宣称 deposit 押金 disposable 可任意处理的 scrutiny 仔细检查 longstanding 长期存在的 levy 征收，收集 inevitable/unavoidable 不可避免的 hysteria 歇斯底里的 venture/exploit 探索/冒险 obsessed 痴迷的 demography/census 人口普查 tentative/hesitate 实验性的/踌躇的 thermal 热的 thermometer 温度计 densely covered thermal springs 分布密集的温泉 depict/describe/display/representation/portraying 描绘/描述/展现 pilot 试点/飞行员 hail/praise/honor 赞誉，表扬 permanent/perpetual/immortal/eternal/ 永恒的 rapidly/astonishing rate 迅速的 move/relocate 搬家 better housing/newly constructed 新装修 agree with/gain support 赞同 problems/difficulty 问题 negative/critical 批判性的 appear/print 显现 completion/add 完成 cover/laid on top 覆盖 travel/journey 旅行 use/utilise/add 使用 pollution/smoke and fumes 污染 different approach/not an option/alternative 不一样的途径 technique/method 科技 financial/profit 盈利 conspiracy/scheme/plot 阴谋策划 malnutrition/undernourished 营养不良 healthy/well-being/wholesome 有益健康的 dismiss/deny/repudiate 拒绝考虑/否定 feel hard done by 觉得受到不公平待遇 evade/evacuate/retreat/withdraw/escape 撤退，逃避 recruit 招募 cruise 巡航 in one’s position 在某人的处境 ingenious 精巧的 justification 正当的理由 validate 使得到认同 ceaselessly 不停地，不断地 chronic/long-term 长期的 utterly/radical/thorough 完全地/彻底的 ceaselessly/relentless 不停地/无情地 preference 偏好 elusive/subtle 微妙的，难以捉摸的 foreseeable/predictable 可预测的 scale 规模，程度，攀登，改变……的大小 disruptions 扰乱，打扰 wedge 楔子，把……挤入，把……抵牢 strangle 限制……的发展 cumulative 累积的，渐增的 vacancy rate 空置率 credentials 资历，资格证书 summon 召唤 credit sb. with sth. 相信某人做了某事 conduct 进行，实施 subjective 主观的 subsequent 随后的 refine 改进，完善 empirically 以经验为主的 confirm 证实 gravely 严重地 devise 设计，想出 ingenious 巧妙的 figure out 弄清楚 subtle 微妙的 fall out of favor 不受欢迎 budding 开始发展的 little regard for sb./sth. 对某人/某事关注很少 at sb.’s disposal 任某人处理，供某人使用 engage sb. in (doing) sth. 使某人参加某事 execute 执行 capitalize on sth. 充分利用某物 repertoire 全部技能 implicitly 隐含其中地 spontaneously 自发地 sympathetic 同情的 involuntary 不自觉的，无意识的 customary 通常地 protagonist 主角 antagonist 对手，敌人 bewilderment 困惑，迷惘 tender age 幼年时期 explicit 清楚说明的 scratch 触及 dismiss 否定 couple sb. with sth. 某物加上某物 dominate 支配，控制 articulate 明确表达 act out 表演 Writing","link":"/2022/09/07/MY%20IELTS%20ROADS/"},{"title":"Leetcode TOP K","text":"来源：Top K 许多应用程序都需要处理有序的元素，但不一定要求他们全部有序，或者不一定一次就将他们排序，很多时候，我们每次只需要操作数据中的最大元素（最小元素），有一种基于二叉堆的数据结构可以提供支持。 所谓二叉堆，是一个完全二叉树，同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）其父节点。 堆排序正是抓住这一特点，每次都取堆顶元素，然后将剩余的元素重新调整到最大（最小）堆，依此类推，最终得到排序的序列。 完全二叉树推论一：对于位置为$k$的节点，左子节点为$2\\times{k}+1$，右子节点为$2\\times{k}+2$ 推论二：最后一个非叶节点的位置为$\\frac{n}{2}-1$，$n$为数组长度 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution { public int[] getLeastNumbers(int[] arr, int k) { if (k == 0) return new int[0]; int len = arr.length; if (k == len) return arr; //对arr数组的前k个数建堆 int[] heap = new int[k]; for (int i = 0; i &lt; k; i++) heap[i] = arr[i]; buildHeap(heap); //对后面的数进行遍历，如果有比堆顶的数(这个堆中最大的一个数，如果比他大，那么说明这个数被淘汰了)，更新堆顶元素的值为这个更小的数，然后对堆进行维护，即还是要保证堆顶的元素是这个堆中最大的数。 for (int i = k; i &lt; len; i++) { if (arr[i] &lt; heap[0]) { heap[0] = arr[i]; heapify(heap, 0); } } //返回这个堆 return heap; } //建堆。堆其实是一颗完全二叉树，用数组实现，具体可百度。节点i的父节点和子节点可通过如下的计算得到。 //对于一个还没维护过的堆，从他的最后一个节点的父节点开始进行heapify,知道堆顶 //parent = (i - 1) / 2; child1 = 2 * i + 1(左节点);, child2 = 2 * i + 2(右节点); private void buildHeap(int[] nums) { //最后一个节点 int lastNode = nums.length - 1; //最后一个节点的父节点 int startHeapify = (lastNode - 1) / 2; //开始heapify直到最后 while (startHeapify &gt;= 0) { heapify(nums, startHeapify--); } } //维护大顶堆的函数，和当前节点的左右节点比较，如果节点中有更大的数，那么交换，并继续对交换后的节点进行维护 //i:要维护的节点。 private void heapify(int[] nums, int i) { int len = nums.length; if (i &gt;= len) return; //左右子节点 int c1 = ((i &lt;&lt; 1) + 1), c2 = ((i &lt;&lt; 1) + 2); //假定节点i是这三个点(i节点，i节点的左子节点，i节点的右子节点)中最大的那个数 int max = i; //如果左子节点比较大，max更新为max = c1; if (c1 &lt; len &amp;&amp; nums[c1] &gt; nums[max]) max = c1; //如果右子节点比较大，max更新为max = c2; if (c2 &lt; len &amp;&amp; nums[c2] &gt; nums[max]) max = c2; //如果最大的数不是节点i的话，那么heapify(nums, max)，即调整节点i的子树。 if (max != i) { swap(nums, max, i); heapify(nums, max); } } //交换数组中i索引和j索引元素的位置 private void swap(int[] nums, int i, int j) { nums[i] = nums[i] + nums[j] - (nums[j] = nums[i]); } } Kth Largest Element in an Array (215)Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity. 12345Input: nums = [3,2,1,5,6,4], k = 2Output: 5Input: nums = [3,2,3,1,2,4,5,5,6], k = 4Output: 4 大根堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int findKthLargest(int[] nums, int k) { int n = nums.length; build_maxHeap(nums); for (int i = 0; i &lt; k - 1; i ++) { int tmp = nums[0]; nums[0] = nums[n-1-i]; nums[n-1-i] = tmp; adjust_down(nums, 0, n-1-i - 1); } return nums[0]; } public void build_maxHeap(int [] nums) { int n = nums.length; for (int root = n/2; root &gt; -1; root --) { adjust_down(nums, root, n - 1); } } public void adjust_down(int [] nums, int root, int hi) { if (root &gt; hi) return ; int t = nums[root]; int child = 2 * root + 1; while (child &lt;= hi) { if (child + 1 &lt;= hi &amp;&amp; nums[child] &lt; nums[child + 1]) child ++; if (t &gt; nums[child]) break; nums[root] = nums[child]; root = child; child = 2 * root + 1; } nums[root] = t; }} 快速排序 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int findKthLargest(int[] nums, int k) { int n = nums.length; int l = 0; int r = n - 1; while (true) { int idx = partition(nums, l, r); if (idx == k - 1) return nums[idx]; else if (idx &lt; k - 1) l = idx + 1; else r = idx - 1; } }//左右挖坑互填 public int partition(int [] nums, int l, int r) { int pivot = nums[l]; while (l &lt; r) { while (l &lt; r &amp;&amp; nums[r] &lt;= pivot) r --; nums[l] = nums[r]; while (l &lt; r &amp;&amp; nums[l] &gt;= pivot) l ++; nums[r] = nums[l]; } nums[l] = pivot; return l; }} Top K Frequent Elements (347)Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. 1234Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]Input: nums = [1], k = 1Output: [1] Follow up: Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.","link":"/2022/09/08/Leetcode%20TOP%20K/"}],"tags":[{"name":"Reading","slug":"Reading","link":"/tags/Reading/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"Iterative","slug":"Iterative","link":"/tags/Iterative/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","link":"/tags/StringBuffer/"},{"name":"StringBuilder","slug":"StringBuilder","link":"/tags/StringBuilder/"},{"name":"GC","slug":"GC","link":"/tags/GC/"},{"name":"Vocabulary","slug":"Vocabulary","link":"/tags/Vocabulary/"},{"name":"Two pointers","slug":"Two-pointers","link":"/tags/Two-pointers/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Traverse","slug":"Traverse","link":"/tags/Traverse/"},{"name":"Auxiliary Stack","slug":"Auxiliary-Stack","link":"/tags/Auxiliary-Stack/"},{"name":"HashSet","slug":"HashSet","link":"/tags/HashSet/"},{"name":"Fast and slow pointers","slug":"Fast-and-slow-pointers","link":"/tags/Fast-and-slow-pointers/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Process","slug":"Process","link":"/tags/Process/"},{"name":"Schedule","slug":"Schedule","link":"/tags/Schedule/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"JRE","slug":"JRE","link":"/tags/JRE/"},{"name":"IO Model","slug":"IO-Model","link":"/tags/IO-Model/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Speaking","slug":"Speaking","link":"/tags/Speaking/"},{"name":"Writing","slug":"Writing","link":"/tags/Writing/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"Complete Binary Tree","slug":"Complete-Binary-Tree","link":"/tags/Complete-Binary-Tree/"},{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"}],"categories":[{"name":"Tips","slug":"Tips","link":"/categories/Tips/"},{"name":"News","slug":"News","link":"/categories/News/"},{"name":"Concepts","slug":"Concepts","link":"/categories/Concepts/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"Summary","slug":"Summary","link":"/categories/Summary/"}]}