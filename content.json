{"pages":[{"title":"About","text":"","link":"/about/index.html"}],"posts":[{"title":"Climbing Stairs","text":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 12345Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 123456Input: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 来源：力扣（LeetCode） 超时解法：无脑递归1234567891011public class climbStairs { public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; return climbStairs(n - 1) + climbStairs(n - 2); } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：$O(2^n)$ （每层递归的complexity是上一层的2倍）空间复杂度：$O(n)$ （递归层数） 为什么这里空间复杂度是O(n)? 递归的空间复杂度是：递归的深度*每次递归所需的辅助空间的个数 辅助空间指的是为局部变量和形参所开辟的空间，对于递归算法，由于运行时有附加堆栈，所以递归的空间复杂度是递归的深度*每次压栈所需的空间个数。 递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数递归最深的那一次所耗费的空间足以容纳它所有递归过程。（递归是要返回上一层的，所以它所需要的空间不是一直累加起来的） 所以最深的那次压栈就是递归的空间复杂度。递归的深度是n，而每次递归所需的辅助空间个数为1。 由上图可知，很多节点重复求解多次，所以可以使用HashMap来保存求解过程中已经求过的值。 HashMap12345678910111213141516171819202122import java.util.HashMap;import java.util.Map;public class climbStairs { private static Map&lt;Integer, Integer&gt; storeMap = new HashMap&lt;&gt;(); public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; if (storeMap.get(n) != null) { return storeMap.get(n); } else { int result = climbStairs(n - 1) + climbStairs(n - 2); storeMap.put(n, result); return result; } } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：O(n) （链表）空间复杂度：O(n) （存储桶，链表） JDK1.8之前，HashMap底层实现用的是数组+链表，HashMap通过hash计算key的哈希值，然后hash%n（n为数组长度，初始化数组默认长度为16），得到key在数组中存放的下标；当出现哈希冲突时（两个key在数组中存放的下标一致），数据以链表形式存储；在链表中查找数据必须从第一个元素开始一层一层地往下找，直到找到为止，时间复杂度为O(n)，所以当链表长度越来越长时，HashMap的效率越来越低。 JDK1.8之后，corporate into了红黑树，当链表中的元素超过8（TREEIFY_THRESHOLD），并且数组长度大于64（MIN_TREEIFY_CAPACITY）时，会将链表转换为红黑树，转换之后数据查询的时间复杂度从O(n)降至O(logn)。 递归转循环12345678910111213public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int result = 0; int pre = 2; int prePre = 1; for (int i = 3; i &lt;= n; ++i) { result = pre + prePre; prePre = pre; pre = result; } return result;} 时间复杂度：O(n)空间复杂度：O(1) （辅助空间是常数级别的）","link":"/2022/08/29/Climbing-Stairs/"},{"title":"Reverse Linked List","text":"Given the head of a singly linked list, reverse the list, and return the reversed list. 12Input: head = [1,2,3,4,5]Output: [5,4,3,2,1] 来源：力扣（LeetCode） 双指针迭代： 定义双指针：pre 和 cur 局部反转：cur.next=pre pre 和 cur 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 123456789101112131415161718192021222324252627282930313233343536373839404142public class reverseNode { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static void printList(ListNode head) { ListNode cur = head; while (cur != null) { System.out.printf(\"%d \", cur.val); cur = cur.next; } } public static void main(String[] args) { ListNode node5 = new ListNode(5, null); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); ListNode pre = reverseList(node1); printList(pre); }} 时间复杂度：O(n)空间复杂度：O(1) 双指针迭代：另一种思路，充分运用head头节点 12345678910111213public static ListNode reverseList(ListNode head) { if (head == null) { return null; } ListNode cur = head; while (head.next != null) { ListNode tmp = head.next.next; head.next.next = cur; cur = head.next; head.next = tmp; } return cur;} 时间复杂度：O(n)空间复杂度：O(1) 递归： 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789public static ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode cur = reverseList(head.next); head.next.next = head; head.next = null; return cur;} 时间复杂度：O(n)空间复杂度：O(n) 空间复杂度指的是执行算法需要的辅助存储空间相对于数据规模的增长关系，算的是变量的个数，对于递归程序，每递归一次都在栈上开辟一块内存，所以递归了多少次就开辟了多少块内存，开辟的那些内存就是空间复杂度，因为递归了n次，所以递归的空间复杂度为O(n)。","link":"/2022/08/29/Reverse%20Linked%20List/"},{"title":"Linked List Cycle","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;next&nbsp;pointer. Internally, pos&nbsp;is used to denote the index of the node that&nbsp;tail’s&nbsp;next&nbsp;pointer is connected to.&nbsp;Note that&nbsp;pos&nbsp;is not passed as a parameter. Return&nbsp;true if there is a cycle in the linked list. Otherwise, return false. 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 来源：力扣（LeetCode） 快慢指针：跑的快的总能套圈12345678910111213141516171819202122232425262728293031323334353637public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slowPtr = head, fastPtr = head; while (fastPtr.next != null &amp;&amp; fastPtr.next.next != null) { slowPtr = slowPtr.next; fastPtr = fastPtr.next.next; if (slowPtr == fastPtr) return true; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中的节点数）空间复杂度：O(1) （只使用了两个指针的额外空间） 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 n 轮。 HashSet不重复的添加，添加元素时会判断是否已经存在,已经存在会添加不成功 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashSet;import java.util.Set;public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { Set seen = new HashSet(); while (head != null) { if (!seen.add(head)) return true; head = head.next;// if (seen.contains(head)) return true;// seen.add(head);// head = head.next; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中节点数）空间复杂度：O(n) （主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次） https://blog.csdn.net/weixin_45453739/article/details/122644349 Relevant Problem给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 不允许修改链表。 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 进阶：你是否可以使用 O(1) 空间解决此题？ 快慢指针： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static ListNode detectCycle(ListNode head) { if (head == null) return null; ListNode tortoise = head, rabbit = head; boolean loopExists = false; while (rabbit.next != null &amp;&amp; rabbit.next.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; if (tortoise == rabbit) { loopExists = true; break; } } if (loopExists == true) { tortoise = head; while (tortoise != rabbit) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(detectCycle(node1).val); }}","link":"/2022/08/29/Linked-List-Cycle/"},{"title":"Merge Two Sorted Lists","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 12Input: list1 = [1,2,4], list2 = [1,3,4]Output: [1,1,2,3,4,4] 12Input: list1 = [], list2 = []Output: [] 12Input: list1 = [], list2 = [0]Output: [0] 来源：力扣（LeetCode） 循环+双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class mergeTwoSortedLists { public static class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode resultNode = new ListNode(0); ListNode p = resultNode; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) p.next = list1; if (list2 != null) p.next = list2; return resultNode.next; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(2); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(4); ListNode node6 = new ListNode(4); node1.next = node3; node3.next = node5; node2.next = node4; node4.next = node6; ListNode node = mergeTwoLists(node1, node2); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n+m)空间复杂度：O(1) 递归12345678910public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val &lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } list2.next = mergeTwoLists(list1, list2.next); return list2;} 时间复杂度：O(n+m)空间复杂度：O(n+m)","link":"/2022/08/29/Merge%20Two%20Sorted%20Lists/"},{"title":"Implement Queue using Stacks","text":"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：你只能使用标准的栈操作 —— 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 来源：力扣（LeetCode） 构造的时候要时刻记住此方法非彼方法，一个自己实现的queue方法，一个是stack类提供的方法 123IsEmpty:false3 1 2 IsEmpty:true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Stack;class MyQueue { Stack&lt;Integer&gt; stack1; Stack&lt;Integer&gt; stack2; /** * Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } /** * Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { if (!stack1.isEmpty()) { in2out(); } return stack2.pop(); } /** * Get the front element. */ public int peek() { if (!stack1.isEmpty()) { in2out(); } return stack2.peek(); } /** * Returns whether the queue is empty. */ public boolean empty() { if (!stack1.isEmpty()) { return stack1.isEmpty(); } else return stack2.isEmpty(); } public void in2out() { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } public static void main(String[] args) { MyQueue queue = new MyQueue(); queue.push(3); queue.push(1); queue.push(2); System.out.println(\"IsEmpty:\" + queue.empty()); while (!queue.empty()) { System.out.print(queue.peek() + \" \"); queue.pop(); } System.out.println(\"\\nIsEmpty:\" + queue.empty()); }} 看似没什么问题，然而 是不是push写错了？ 12345678910public void push(int x) { if (!stack2.isEmpty()) { while (!stack2.isEmpty()) { Integer pop = stack2.pop(); stack1.push(pop); } stack1.push(x); } else stack1.push(x);} 事实上，这个方法没写全，如果stack2为空，将stack1中的元素全部放到stack2中 12345public void in2out() { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } 1234567public void in2out() { if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } }","link":"/2022/08/29/Implement-Queue-using-Stacks/"},{"title":"Intersection of Two Linked Lists","text":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. 注意，函数返回结果后，链表必须保持其原始结构。 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 12345输入：intersectVal&nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 来源：力扣（LeetCode） 双指针：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class intersectLinkedList { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } public ListNode() { } } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; } public static void main(String[] args) { ListNode node1 = new ListNode(4); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(8); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); ListNode node6 = new ListNode(1); ListNode node7 = new ListNode(6); ListNode node8 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node8.next = node7; node7.next = node6; node6.next = node3; System.out.print(getIntersectionNode(node1, node8).val); }} 两链表从同一位置开始遍历：128 1 6 3 2 70 8 1 6 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class intersectLinkedList { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } public ListNode() { } } public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { int L1 = 0, L2 = 0, diff = 0; ListNode head1 = headA, head2 = headB; while (head1 != null) { L1++; head1 = head1.next; } while (head2 != null) { L2++; head2 = head2.next; } if (L1 &lt; L2) { head1 = headB; head2 = headA; diff = L2 - L1; } else { head1 = headA; head2 = headB; diff = L1 - L2; } for (int i = 0; i &lt; diff; i++) head1 = head1.next; while (head1 != null &amp;&amp; head2 != null) { if (head1 == head2) return head1; head1 = head1.next; head2 = head2.next; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(8); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(6); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(2); ListNode node6 = new ListNode(7); ListNode node7 = new ListNode(0); ListNode node8 = new ListNode(2); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = node6; node7.next = node1; node3.next = node8; System.out.print(getIntersectionNode(node1, node7).val); }}","link":"/2022/08/29/Intersection-of-Two-Linked-Lists/"},{"title":"Remove Duplicates from Sorted List","text":"Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 12Input: head = [1,1,2]Output: [1,2] 12Input: head = [1,1,2,3,3]Output: [1,2,3] 来源：力扣（LeetCode） 遍历链表：如果next和当前重复了，就把next指向next的next，否则当前指向next。 1234567891011121314151617181920212223242526272829303132333435363738394041public class duplicateRemoval { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode deleteDuplicates(ListNode head) { if (head == null) { return head; } ListNode currentNode = head; while (currentNode != null &amp;&amp; currentNode.next != null) { if (currentNode.next.val == currentNode.val) { currentNode.next = currentNode.next.next; } else { currentNode = currentNode.next; } } return head; } public static void main(String[] args) { ListNode node5 = new ListNode(3, null); ListNode node4 = new ListNode(3, node5); ListNode node3 = new ListNode(2, node4); ListNode node2 = new ListNode(1, node3); ListNode node1 = new ListNode(1, node2); ListNode node = deleteDuplicates(node1); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n) （每一个节点都要检查一次确定是否重复）空间复杂度：O(1) （没有使用额外空间） 双指针：12345678910111213141516public static ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head; while (pre != null) { if (pre.val != cur.val) { cur.next = pre; cur = cur.next; } pre = pre.next; } cur.next = null; return head;} 递归：1234567public static ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head;} 时间复杂度：O(n)","link":"/2022/08/29/Remove-Duplicates-from-Sorted-List/"},{"title":"Palindrome Linked List","text":"Given the head of a singly linked list, return true if it is a palindrome or false otherwise. 12Input: head = [1,2,2,1]Output: true 12Input: head = [1,2]Output: false 来源：力扣（LeetCode） 快慢指针+反转链表：中规中矩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PalindromeLinkedList { public static class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseNode(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static boolean isPalindrome(ListNode head) { ListNode tortoise = head, rabbit = head; while (rabbit != null &amp;&amp; rabbit.next != null) { rabbit = rabbit.next.next; tortoise = tortoise.next; } if (rabbit != null) tortoise = tortoise.next; //如果链表为奇数节点，慢指针指向下一个节点，把正中间节点让给左边 tortoise = reverseNode(tortoise); rabbit = head; while (tortoise != null) { if (tortoise.val != rabbit.val) return false; rabbit = rabbit.next; tortoise = tortoise.next; } return true; } public static void main(String[] args) { ListNode node4 = new ListNode(1, null); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); System.out.print(isPalindrome(node1)); }} 合一块 12345678910111213141516171819202122232425public static boolean isPalindrome(ListNode head) { if (head == null || head.next == null) { return true; } ListNode slow = head, fast = head; ListNode pre = null; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; ListNode temp = slow.next; slow.next = pre; pre = slow; slow = temp; } if (fast != null) { slow = slow.next; } while (pre != null &amp;&amp; slow != null) { if (pre.val != slow.val) { return false; } pre = pre.next; slow = slow.next; } return true;} Relevant Problem 1Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 来源：力扣（LeetCode） 123Input: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3. 123Input: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. 天然适配双指针： 123456789101112131415161718192021222324252627282930313233343536373839public class MiddleOfTheLinkedList { public static class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode middleNode(ListNode head) { ListNode tortoise = head, rabbit = head; while (rabbit != null &amp;&amp; rabbit.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; } return tortoise; } public static void main(String[] args) { ListNode node6 = new ListNode(6, null); ListNode node5 = new ListNode(5, node6); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); System.out.println(middleNode(node1).val); }} Relevant Problem 2剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 来源：力扣（LeetCode） 12给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 快慢指针：12345678910111213141516171819202122232425262728293031323334353637public class BottomK { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode getKthFromEnd(ListNode head, int k) { ListNode tortoise = head, rabbit = head; while (k-- != 0) { rabbit = rabbit.next; } while (rabbit != null) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(getKthFromEnd(node1, 2).val); }} 时间复杂度：O(n)空间复杂度：O(1) 距离表示另一种解决此题的思路是：对链表进行一次完整遍历，拿到总长度cnt，cnt-k即是倒数第k个节点与head节点之间的距离 1234567891011public static ListNode getKthFromEnd(ListNode head, int k) { int cnt = 0; ListNode tmp = head; while (tmp != null) { tmp = tmp.next; cnt++; } cnt = cnt - k; while (cnt-- != 0) head = head.next; return head;} 时间复杂度：O(n)空间复杂度：O(1) 栈/队列：一个使用额外空间的解法是利用栈（队列），将所有的节点压入占中栈（队列）中，令当前栈（队列）容量为 cnt。 然后从栈顶（队列头）弹出 k 个（cnt - k + 1个）元素，最后一个出栈（出队列）的元素即是答案。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayDeque;import java.util.Deque;public class BottomK { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode getKthFromEnd(ListNode head, int k) { Deque&lt;ListNode&gt; d = new ArrayDeque&lt;&gt;(); while (head != null) { d.addLast(head); head = head.next; } ListNode ans = null; while (k-- &gt; 0) ans = d.pollLast(); return ans; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(getKthFromEnd(node1, 2).val); }} 时间复杂度：O(n)空间复杂度：O(n)","link":"/2022/08/29/Palindrome-Linked-List/"},{"title":"Decode String","text":"给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像&nbsp;3a&nbsp;或&nbsp;2[4]&nbsp;的输入。 12输入：s = \"3[a]2[bc]\"输出：\"aaabcbc\" 来源：力扣（LeetCode） StringBuilder12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class StringDecoding { public static String decodeString(String s) { StringBuilder res = new StringBuilder(); int multi = 0; Stack&lt;Integer&gt; stack_multi = new Stack&lt;Integer&gt;(); Stack&lt;String&gt; stack_res = new Stack&lt;String&gt;(); for (Character c : s.toCharArray()) { if (c == '[') { stack_multi.push(multi); stack_res.push(res.toString()); multi = 0; res = new StringBuilder(); } else if (c == ']') { StringBuilder tmp = new StringBuilder(); int cur_multi = stack_multi.pop(); for (int i = 0; i &lt; cur_multi; i++) { tmp.append(res); } res = new StringBuilder(stack_res.pop() + tmp); } else if (c &gt;= '0' &amp;&amp; c &lt;= '9') { multi = multi * 10 + c - '0'; } else res.append(c); } return res.toString(); } public static void main(String[] args) { String s = \"3[a]2[bc]\"; System.out.println(decodeString(s)); }} String、StringBuffer与StringBuilder String StringBuffer StringBuilder String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。也由于它的不可变性，类似拼接、裁剪字符串等动作，每次对String的操作都会生成新的 String对象。 为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，减小了开销，是绝大部分情况下进行字符串拼接的首选。 StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 参考：https://www.joshua317.com/article/241 StringBuilder和String可以相互转换 String-&gt;StringBuilder：可以使用StringBuilder的构造方法，StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder-&gt;String：可以使用StringBuilder中的toString方法。public String toString() 将当前StringBuilder对象转换为String对象。 Integer.parseInt(String s)具有参数类型String，而不是number.charAt(i)返回的char。 转换为String： 1a.add(Integer.parseInt(\"\" + number.charAt(i)));","link":"/2022/08/29/Decode-String/"},{"title":"How to Expand Your Vocabulary","text":"来源：How to Expand Your Vocabulary? Lexical resource is a very important marking criterion in IELTS writing and speaking which implies using a wide range of vocabulary accurately. Apart from this, vocabulary knowledge will also help you a lot in reading. Thus, it is one of the reasons why students worry a lot for learning new words which they can use while they speak or write. Also, that candidates who receive less than 5 band have limited vocabulary while 7 band and above use a wide range of vocabulary and hence, vocabulary is essential for IELTS preparation.Let us consider some of the tips for expanding vocabulary. Read NewspapersReading is the best habit to learn new words and it will also help you to improve your skills for IELTS reading module. You can subscribe a daily or weekly newspaper online or offline and have the habit of reading articles on a daily basis. While you read articles, do underline the words that you do not know or notice carefully if you come to know about the use of a word in a different way. Then, check the word meaning in your dictionary and write down in your notebook. Learn the noted words and do revise them once or twice a week. Useful Links: http://www.bbc.com/news/http://www.economist.com/ Keep a DictionaryA very common method of learning vocabulary is to keep a small pocket-sized dictionary with you. If you never devoted time to learn new words in this way, you can develop this habit now. There are two ways you can use your dictionary to learn words. Firstly, you can refer it any time you come across a new word and check its meaning in the dictionary. Secondly, you can start learning the words in sequence from first to the last page of your dictionary. In this way, you can at least become familiar to new words every day and depending upon how much time you devote per day, you may be able to read all the words in your dictionary in several days or months. However, for effective learning, keep in mind to learn a word whole-heartedly. If you feel you cannot understand a word, just skip it because learning a word incorrectly is even more dangerous. Learn vocabulary effectively in the following way: Check the word meaning (in English and/or in your native language) Learn its right pronunciation Learn its synonyms Use this word to form a sentence Practice more and more while speaking and writing For example: Perception meaning– Ability to see through perceptionSynonyms – Awareness, recognitionExample: Different people have different perception about beauty. Useful Link: http://www.enchantedlearning.com/Aisfor.shtmlhttp://www.oxfordlearnersdictionaries.com/wordlist/english/academic/http://dictionary.cambridge.org/browse/pronunciation/http://www.thesaurus.com/browse/perception (Search a keyword to know synonyms) Listen to Audios &amp; Watch VideosThe best way of learning the usage of a new word is when you listen to it being used by others. So, you can watch TV programmes, news channels, movies, YouTube videos, group discussions, talk shows etc. You can also listen to audios such as podcasts, songs, radio channels etc. One more thing is that you can prefer watching or listening to the stuff that you find interesting so that you may not get bored and stop your plan to learn vocabulary. The concept behind this method is that you are exposed to new words and hence, you learn faster in this way. When you watch videos or listen to some audios, pay more attention to the words and how they are used. Watching video stuff online is also a good idea where you can pause or replay the videos to learn at your own pace. You can start by listening to videos which have sub-titles. This will help you improve your comprehension as well as listening skills. In case, you come across a new word, use the dictionary to find the meaning and at least one synonym. Learn with FunNowadays, there are many games available on the websites and game applications can also be installed in mobile phones which can be some of the most interesting and exciting ways to learn vocabulary. This will definitely help those who find it boring to read books. Useful Links: http://eslgamesworld.com/members/games/levels/high/index.html Learn Idioms &amp; ConnectivesUse of idiomatic language and sentence connectors while you speak on a topic would be effective. In academic writing task 1, you should use connectives while idioms can be be avoided as they are used for informal writing. And hence, students appearing in IELTS General Training may use them while writing a letter. But make sure you use them when required and do not unnecessarily try to include them excessively. Useful Link: http://idioms.thefreedictionary.com/ Practice is the key!Practicing using the vocabulary is extremely important, otherwise you will forget a word even after noting it down. Target number of words to be learnt daily and revise them every week by practicing their use in writing and speaking. In this way, you are really going to improve your knowledge of new words and getting familiar with them. The more you practice, the more you can use them naturally as it is also essential that you don’t hesitate while using the newly learnt words.Lastly, while you learn words, you can also further ensure that you know the correct use in terms of spelling, punctuation, usage in a sentence and collocation (combination of words)","link":"/2022/08/29/How%20to%20Expand%20Your%20Vocabulary/"}],"tags":[{"name":"Two pointers","slug":"Two-pointers","link":"/tags/Two-pointers/"},{"name":"Iterative","slug":"Iterative","link":"/tags/Iterative/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"HashSet","slug":"HashSet","link":"/tags/HashSet/"},{"name":"Fast and slow pointers","slug":"Fast-and-slow-pointers","link":"/tags/Fast-and-slow-pointers/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","link":"/tags/StringBuffer/"},{"name":"StringBuilder","slug":"StringBuilder","link":"/tags/StringBuilder/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Vocabulary","slug":"Vocabulary","link":"/tags/Vocabulary/"}],"categories":[{"name":"DataStructure","slug":"DataStructure","link":"/categories/DataStructure/"},{"name":"Tips","slug":"Tips","link":"/categories/Tips/"}]}