{"pages":[{"title":"About","text":"Gallery Netease","link":"/about/index.html"}],"posts":[{"title":"雅思之路","text":"VocabularyNew words en zh-cn cogent 有说服力的 portfolio 公文包，投资方案 collude 共谋，串通，勾结 scam 阴谋 conviction 确信 determination 决心 cultivate 耕作，种植 sophisticated 老练的，尖端的，有教养的 veteran 老手，老练的 veterinarian 兽医 spores 孢子 infiltrate 渗透，渗入人的心中 penetrate 渗透，透过 permeate 渗透，弥散，传播 constrain 强迫，约束 compel 在法律，权利等驱使下被迫而为 oblige 出于生理上道德上需要，促使某人做某事 impose 强迫 compulsory 强制的 mandatory 强制的 faint 昏厥，微弱的 dizzy 头晕的 bewildered 困惑的 dazzling 头晕目眩的 consent 同意 consistent 一致 uniform 制服，一致 halt 停止 cease 终结 paramount 至高无上的 facility 设备，容易 abbey 修道院，大教堂 legislation 法规 outlaw 非法的 discrimination 歧视 segregation 隔离并区别对待 disorder 障碍 imperative 迫切的 diplomatic 外交的 prevalence 流行 confiscate 没收 marvelous 了不起的 periodical 期刊 Synonymous en zh-cn working week/professional schedule 工作日程 developed countries/industrialized countries 发达国家 serious problems/severe(critical) issues/major concern 严重问题 advantages and disadvantages/pros and cons 优点和缺点 appear to/seem to 似乎是 Writing Part 2Sentence restructuring origin transformation Unemployment is one of the most serious problems facing developed nations today. It seems increasingly normal for people of industrialized countries to confront umemployment, one of their toughest problems./Lack of jobs is indeed a major concern among many industrialized countries. Some argue that a 35-hour working week is a possible solution to unemployment. What are the advantages and disadvantages of this solution? In this essay, I will outline the pros and cons of lessening professional schedules to thirty five hours. Reference雅思作文,25个万能逻辑链,搞定100个高频题,你能看懂吗？63个高分句式真题练习雅思作文想不出来怎么办Simon全套雅思写作教程 var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"スパークル\",\"author\":\"RADWIMPS\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661491/rm7BsWHz_%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF%E3%83%AB%20%28movie%20ver.%29-RADWIMPS.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661484/aGk0yPw4_18597139672292692.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661507/S1cBUVM2_%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF%E3%83%AB%20%28movie%20ver.%29-RADWIMPS.lrc\"}]}; options.element = document.getElementById(\"aplayer-aaZqmJpp\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/19/%E9%9B%85%E6%80%9D%E4%B9%8B%E8%B7%AF/"},{"title":"快速排序","text":"参考：十大经典排序算法 基本思想快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序 123456789101112131415161718192021222324252627282930313233343536373839public class quicksort { public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; int low = left; int high = right; int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { int temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 切换插入排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class quicksort { private static final int INSERT_SORT_THRESHOLD = 7; public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int low = left; int high = right; int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { int temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 随机化选择切分元素pivot否则在输入为有序数组时，快速排序会变得非常慢O(n^2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Random;public class quicksort { private static final int INSERT_SORT_THRESHOLD = 7; private static final Random RANDOM = new Random(); public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int low = left; int high = right; int randomIndex = RANDOM.nextInt(right - left + 1) + left; swap(nums, left, randomIndex); int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { swap(nums, low, high); } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 例题数组中的第K个最大元素（215）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution { //插入排序优化区间长度 - 1 int CUTOFF = 1; public int findKthLargest(int[] nums, int k) { quickSelect(nums, 0, nums.length - 1, k); return nums[nums.length - k]; } //三路快速选择 private void quickSelect(int[] nums, int l, int r, int k){ //插入排序优化 if(l + CUTOFF &gt; r){ insertSort(nums, l, r); return ; } int pivot = median(nums, l, r); int lt = l; int gt = r - 1; int i = l; while(i &lt; gt){ if(nums[i] &lt; pivot){ swap(nums, i, lt); i ++; lt ++; }else if(nums[i] &gt; pivot){ swap(nums, i, gt - 1); gt --; }else{ i ++; } } swap(nums, gt, r - 1); //根据 n-k 的位置，选择排序区间 if(nums.length-k &lt; lt){ quickSelect(nums, l, lt - 1, k); }else if(nums.length-k &gt; gt){ quickSelect(nums, gt + 1, r, k); } } //三数中值法取枢纽元 private int median(int[] nums, int l, int r){ int m = l + (r - l) / 2; if(nums[m] &lt; nums[l]){ swap(nums, m, l); } if(nums[r] &lt; nums[l]){ swap(nums, r, l); } if(nums[r] &lt; nums[m]){ swap(nums, r, m); } swap(nums, m, r - 1); return nums[r - 1]; } //插入排序 private void insertSort(int[] nums, int l, int r){ for(int p=l+1; p&lt;=r; p++){ int j = p; int tmp = nums[p]; for(; j&gt;l &amp;&amp; nums[j-1]&gt;tmp; j--){ nums[j] = nums[j-1]; } nums[j] = tmp; } } private void swap(int[] nums, int i, int j){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; }} var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"イエスタデイ\",\"author\":\"official髭男dism\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664075272/pOaVTuz7_892668472.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664075897/8hSEK0Aj_official.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664075281/cQwEJKlf_%E3%82%A4%E3%82%A8%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A4-MusicEnc.lrc\"}]}; options.element = document.getElementById(\"aplayer-ZPdgsnXK\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"无重复字符的最长子串","text":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 1234567输入: s = \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。输入: s = \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 来源：力扣-3 滑动窗口(Sliding Window)关键词： 满足XXX条件（计算结果，出现次数，同时包含） 最长/最短 子串/子数组/子序列（长度最小的子序列） 寻找最长 初始化左右指针L，R在起始点，R向右逐位滑动 每次滑动过程中：如果窗内元素满足条件，R向右扩大窗口，并更新最优结果；如果窗内元素不满足条件，L向右缩小窗口 R到达结尾 寻找最短 初始化左右指针L，R在起始点，R向右逐位滑动 每次滑动过程中：如果窗内元素满足条件，L向右缩小窗口，并更新最优结果；如果窗内元素不满足条件，R向右扩大窗口 R到达结尾 如何判断字串里是否有重复的字符数组 当右指针向右移动将字符纳入滑动窗口的时候，字符的频数加 1； 当左指针向右移动将字符移出滑动窗口的时候，字符的频数减 1。 1234567891011121314151617181920212223public int lengthOfLongestSubstring(String s) { int len = s.length(); if (len &lt; 2) { return len; } int[] freq = new int[128]; //转化为字符数组，避免每一次s.charAt()检查下标越界 char[] charArray = s.toCharArray(); int left = 0; int right = 0; int res = 0; while (right &lt; len) { freq[charArray[right]]++; while (freq[charArray[right]] == 2) { freq[charArray[left]]--; left++; } res = Math.max(res, right - left + 1); right++; } return res;} Hash Map定义一个map存储&lt;k,v&gt;，其中k为字符，v为字符位置+1（+1表示从字符位置后一位才开始不重复）。 1234567891011121314public int lengthOfLongestSubstring(String s) { int len = s.length(); int res = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int end = 0, start = 0; end &lt; len; end++) { char value = s.charAt(end); if (map.containsKey(value)) { start = Math.max(map.get(value), start); } res = Math.max(res, end - start + 1); map.put(s.charAt(end), end + 1); } return res;} var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"Gasshow\",\"author\":\"illion\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664101096/ZVbno5z8_233194916.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664101099/vrMWfKcI_yojiro.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664101095/zMMJszbp_Gasshow-MusicEnc.lrc\"}]}; options.element = document.getElementById(\"aplayer-QeEsnJZc\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/25/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"}],"tags":[{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Insert Sort","slug":"Insert-Sort","link":"/tags/Insert-Sort/"},{"name":"Optimization of Sort","slug":"Optimization-of-Sort","link":"/tags/Optimization-of-Sort/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Hash Map","slug":"Hash-Map","link":"/tags/Hash-Map/"}],"categories":[{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"},{"name":"笔耕不辍","slug":"笔耕不辍","link":"/categories/%E7%AC%94%E8%80%95%E4%B8%8D%E8%BE%8D/"},{"name":"勤能补拙","slug":"勤能补拙","link":"/categories/%E5%8B%A4%E8%83%BD%E8%A1%A5%E6%8B%99/"}]}