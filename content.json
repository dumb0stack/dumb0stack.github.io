{"pages":[{"title":"About","text":"Gallery Netease","link":"/about/index.html"}],"posts":[{"title":"雅思之路","text":"VocabularyNew words en zh-cn cogent 有说服力的 portfolio 公文包，投资方案 collude 共谋，串通，勾结 scam 阴谋 conviction 确信 determination 决心 cultivate 耕作，种植 sophisticated 老练的，尖端的，有教养的 veteran 老手，老练的 veterinarian 兽医 spores 孢子 infiltrate 渗透，渗入人的心中 penetrate 渗透，透过 permeate 渗透，弥散，传播 constrain 强迫，约束 compel 在法律，权利等驱使下被迫而为 oblige 出于生理上道德上需要，促使某人做某事 impose 强迫 compulsory 强制的 mandatory 强制的 faint 昏厥，微弱的 dizzy 头晕的 bewildered 困惑的 dazzling 头晕目眩的 consent 同意 consistent 一致 uniform 制服，一致 halt 停止 cease 终结 paramount 至高无上的 facility 设备，容易 abbey 修道院，大教堂 legislation 法规 outlaw 非法的 discrimination 歧视 segregation 隔离并区别对待 disorder 障碍 imperative 迫切的 diplomatic 外交的 prevalence 流行 confiscate 没收 marvelous 了不起的 Synonymous en zh-cn working week/professional schedule 工作日程 developed countries/industrialized countries 发达国家 serious problems/severe(critical) issues/major concern 严重问题 advantages and disadvantages/pros and cons 优点和缺点 appear to/seem to 似乎是 Writing Part 2Sentence restructuring origin transformation Unemployment is one of the most serious problems facing developed nations today. It seems increasingly normal for people of industrialized countries to confront umemployment, one of their toughest problems./Lack of jobs is indeed a major concern among many industrialized countries. Some argue that a 35-hour working week is a possible solution to unemployment. What are the advantages and disadvantages of this solution? In this essay, I will outline the pros and cons of lessening professional schedules to thirty five hours. Reference雅思作文,25个万能逻辑链,搞定100个高频题,你能看懂吗？63个高分句式真题练习雅思作文想不出来怎么办Simon全套雅思写作教程 var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"スパークル\",\"author\":\"RADWIMPS\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661491/rm7BsWHz_%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF%E3%83%AB%20%28movie%20ver.%29-RADWIMPS.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661484/aGk0yPw4_18597139672292692.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661507/S1cBUVM2_%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF%E3%83%AB%20%28movie%20ver.%29-RADWIMPS.lrc\"}]}; options.element = document.getElementById(\"aplayer-NLQBDZJH\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/19/%E9%9B%85%E6%80%9D%E4%B9%8B%E8%B7%AF/"},{"title":"快速排序","text":"参考：十大经典排序算法 基本思想快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序 123456789101112131415161718192021222324252627282930313233343536373839public class quicksort { public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; int low = left; int high = right; int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { int temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 切换插入排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class quicksort { private static final int INSERT_SORT_THRESHOLD = 7; public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int low = left; int high = right; int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { int temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 随机化选择切分元素pivot否则在输入为有序数组时，快速排序会变得非常慢O(n^2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Random;public class quicksort { private static final int INSERT_SORT_THRESHOLD = 7; private static final Random RANDOM = new Random(); public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int low = left; int high = right; int randomIndex = RANDOM.nextInt(right - left + 1) + left; swap(nums, left, randomIndex); int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { swap(nums, low, high); } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 例题数组中的第K个最大元素（215）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class topk { private static final int INSERT_SORT_THRESHOLD = 7; public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSortOptimize(int[] nums, int left, int right, int k) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int pivot = median(nums, left, right); int len = nums.length; int low = left; int high = right - 1; int i = left; while (i &lt; high) { if (nums[i] &lt; pivot) { swap(nums, i, low); i++; low++; } else if (nums[i] &gt; pivot) { swap(nums, i, high - 1); high--; } else { i++; } } swap(nums, high, right - 1); if (len - k &lt; low) { quickSortOptimize(nums, left, low - 1, k); } else if (len - k &gt; high) { quickSortOptimize(nums, high + 1, right, k); } } public static int median(int[] nums, int left, int right) { int median = left + (right - left) / 2; if (nums[median] &gt; nums[left]) { swap(nums, median, left); } if (nums[right] &gt; nums[left]) { swap(nums, right, left); } if (nums[right] &gt; nums[median]) { swap(nums, right, median); } swap(nums, median, right - 1); return nums[right - 1]; } public static void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } public static int findKthLargest(int[] nums, int k) { int len = nums.length; quickSortOptimize(nums, 0, len - 1, k); return nums[len - k]; } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6, 9}; System.out.println(findKthLargest(nums, 3)); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution { //插入排序优化区间长度 - 1 int CUTOFF = 1; public int findKthLargest(int[] nums, int k) { quickSelect(nums, 0, nums.length - 1, k); return nums[nums.length - k]; } //三路快速选择 private void quickSelect(int[] nums, int l, int r, int k){ //插入排序优化 if(l + CUTOFF &gt; r){ insertSort(nums, l, r); return ; } int pivot = median(nums, l, r); int lt = l; int gt = r - 1; int i = l; while(i &lt; gt){ if(nums[i] &lt; pivot){ swap(nums, i, lt); i ++; lt ++; }else if(nums[i] &gt; pivot){ swap(nums, i, gt - 1); gt --; }else{ i ++; } } swap(nums, gt, r - 1); //根据 n-k 的位置，选择排序区间 if(nums.length-k &lt; lt){ quickSelect(nums, l, lt - 1, k); }else if(nums.length-k &gt; gt){ quickSelect(nums, gt + 1, r, k); } } //三数中值法取枢纽元 private int median(int[] nums, int l, int r){ int m = l + (r - l) / 2; if(nums[m] &lt; nums[l]){ swap(nums, m, l); } if(nums[r] &lt; nums[l]){ swap(nums, r, l); } if(nums[r] &lt; nums[m]){ swap(nums, r, m); } swap(nums, m, r - 1); return nums[r - 1]; } //插入排序 private void insertSort(int[] nums, int l, int r){ for(int p=l+1; p&lt;=r; p++){ int j = p; int tmp = nums[p]; for(; j&gt;l &amp;&amp; nums[j-1]&gt;tmp; j--){ nums[j] = nums[j-1]; } nums[j] = tmp; } } private void swap(int[] nums, int i, int j){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; }} var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"What Do I Know\",\"author\":\"Ed Sheeran\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/18/1/1663497140/3r1O8poF_obj_wo3DlMOGwrbDjj7DisKw_17318206431_3580_21b0_35a6_f2be45c76753279ee04af30ae14f1bfa.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/18/1/1663497257/fv7mHFUx_109951166151204092.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/18/1/1663497207/MHphbCRN_What%20Do%20I%20Know_-Ed%20Sheeran.lrc\"}]}; options.element = document.getElementById(\"aplayer-PmMMYZMB\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Insert Sort","slug":"Insert-Sort","link":"/tags/Insert-Sort/"},{"name":"Optimization of Sort","slug":"Optimization-of-Sort","link":"/tags/Optimization-of-Sort/"}],"categories":[{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"},{"name":"笔耕不辍","slug":"笔耕不辍","link":"/categories/%E7%AC%94%E8%80%95%E4%B8%8D%E8%BE%8D/"}]}