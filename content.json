{"pages":[{"title":"About","text":"Gallery Netease","link":"/about/index.html"}],"posts":[{"title":"快速排序","text":"参考：十大经典排序算法 基本思想快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序 123456789101112131415161718192021222324252627282930313233343536373839public class quicksort { public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; int low = left; int high = right; int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { int temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 切换插入排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class quicksort { private static final int INSERT_SORT_THRESHOLD = 7; public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int low = left; int high = right; int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { int temp = nums[low]; nums[low] = nums[high]; nums[high] = temp; } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 随机化选择切分元素pivot否则在输入为有序数组时，快速排序会变得非常慢O(n^2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Random;public class quicksort { private static final int INSERT_SORT_THRESHOLD = 7; private static final Random RANDOM = new Random(); public static void insertSort(int[] nums, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = nums[i]; int j = i; while (j &gt; left &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } } public static void quickSort(int[] nums, int left, int right) { if (left &gt; right) return; if (right - left &lt;= INSERT_SORT_THRESHOLD) { insertSort(nums, left, right); return; } int low = left; int high = right; int randomIndex = RANDOM.nextInt(right - left + 1) + left; swap(nums, left, randomIndex); int pivot = nums[left]; while (low &lt; high) { while (low &lt; high &amp;&amp; pivot &lt;= nums[high]) { --high; } while (low &lt; high &amp;&amp; pivot &gt;= nums[low]) { ++low; } if (low &lt; high) { swap(nums, low, high); } } nums[left] = nums[low]; nums[low] = pivot; quickSort(nums, left, low - 1); quickSort(nums, low + 1, right); } public static void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } public static void arraySort(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); for (int i = 0; i &lt; len; i++) { System.out.print(nums[i] + \" \"); } } public static void main(String[] args) { int[] nums = {3, 5, 4, 1, 2, 9, 8, 7, 6}; arraySort(nums); }} 例题数组中的第K个最大元素（215）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution { //插入排序优化区间长度 - 1 int CUTOFF = 1; public int findKthLargest(int[] nums, int k) { quickSelect(nums, 0, nums.length - 1, k); return nums[nums.length - k]; } //三路快速选择 private void quickSelect(int[] nums, int l, int r, int k){ //插入排序优化 if(l + CUTOFF &gt; r){ insertSort(nums, l, r); return ; } int pivot = median(nums, l, r); int lt = l; int gt = r - 1; int i = l; while(i &lt; gt){ if(nums[i] &lt; pivot){ swap(nums, i, lt); i ++; lt ++; }else if(nums[i] &gt; pivot){ swap(nums, i, gt - 1); gt --; }else{ i ++; } } swap(nums, gt, r - 1); //根据 n-k 的位置，选择排序区间 if(nums.length-k &lt; lt){ quickSelect(nums, l, lt - 1, k); }else if(nums.length-k &gt; gt){ quickSelect(nums, gt + 1, r, k); } } //三数中值法取枢纽元 private int median(int[] nums, int l, int r){ int m = l + (r - l) / 2; if(nums[m] &lt; nums[l]){ swap(nums, m, l); } if(nums[r] &lt; nums[l]){ swap(nums, r, l); } if(nums[r] &lt; nums[m]){ swap(nums, r, m); } swap(nums, m, r - 1); return nums[r - 1]; } //插入排序 private void insertSort(int[] nums, int l, int r){ for(int p=l+1; p&lt;=r; p++){ int j = p; int tmp = nums[p]; for(; j&gt;l &amp;&amp; nums[j-1]&gt;tmp; j--){ nums[j] = nums[j-1]; } nums[j] = tmp; } } private void swap(int[] nums, int i, int j){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; }} var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"イエスタデイ\",\"author\":\"official髭男dism\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664075272/pOaVTuz7_892668472.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664075897/8hSEK0Aj_official.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664075281/cQwEJKlf_%E3%82%A4%E3%82%A8%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A4-MusicEnc.lrc\"}]}; options.element = document.getElementById(\"aplayer-UbqGyxea\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"无重复字符的最长子串","text":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 1234567输入: s = \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。输入: s = \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 来源：力扣-3 滑动窗口(Sliding Window)关键词： 满足XXX条件（计算结果，出现次数，同时包含） 最长/最短 子串/子数组/子序列（长度最小的子序列） 寻找最长 初始化左右指针L，R在起始点，R向右逐位滑动 每次滑动过程中：如果窗内元素满足条件，R向右扩大窗口，并更新最优结果；如果窗内元素不满足条件，L向右缩小窗口 R到达结尾 寻找最短 初始化左右指针L，R在起始点，R向右逐位滑动 每次滑动过程中：如果窗内元素满足条件，L向右缩小窗口，并更新最优结果；如果窗内元素不满足条件，R向右扩大窗口 R到达结尾 如何判断字串里是否有重复的字符数组 当右指针向右移动将字符纳入滑动窗口的时候，字符的频数加 1； 当左指针向右移动将字符移出滑动窗口的时候，字符的频数减 1。 1234567891011121314151617181920212223public int lengthOfLongestSubstring(String s) { int len = s.length(); if (len &lt; 2) { return len; } int[] freq = new int[128]; //转化为字符数组，避免每一次s.charAt()检查下标越界 char[] charArray = s.toCharArray(); int left = 0; int right = 0; int res = 0; while (right &lt; len) { freq[charArray[right]]++; while (freq[charArray[right]] == 2) { freq[charArray[left]]--; left++; } res = Math.max(res, right - left + 1); right++; } return res;} Hash Map定义一个map存储&lt;k,v&gt;，其中k为字符，v为字符位置+1（+1表示从字符位置后一位才开始不重复）。 1234567891011121314public int lengthOfLongestSubstring(String s) { int len = s.length(); int res = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int end = 0, start = 0; end &lt; len; end++) { char value = s.charAt(end); if (map.containsKey(value)) { start = Math.max(map.get(value), start); } res = Math.max(res, end - start + 1); map.put(s.charAt(end), end + 1); } return res;} var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"Gasshow\",\"author\":\"illion\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664101096/ZVbno5z8_233194916.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664101099/vrMWfKcI_yojiro.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664101095/zMMJszbp_Gasshow-MusicEnc.lrc\"}]}; options.element = document.getElementById(\"aplayer-JYCzspYt\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/25/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"雅思之路","text":"VocabularyNew words en zh-cn cogent 有说服力的 portfolio 公文包，投资方案 collude 共谋，串通，勾结 scam 阴谋 conviction 确信 determination 决心 cultivate 耕作，种植 sophisticated 老练的，尖端的，有教养的 veteran 老手，老练的 veterinarian 兽医 spores 孢子 infiltrate 渗透，渗入人的心中 penetrate 渗透，透过 permeate 渗透，弥散，传播 constrain 强迫，约束 compel 在法律，权利等驱使下被迫而为 oblige 出于生理上道德上需要，促使某人做某事 impose 强迫 compulsory 强制的 mandatory 强制的 faint 昏厥，微弱的 dizzy 头晕的 bewildered 困惑的 dazzling 头晕目眩的 consent 同意 consistent 一致 uniform 制服，一致 halt 停止 cease 终结 paramount 至高无上的 facility 设备，容易 abbey 修道院，大教堂 legislation 法规 outlaw 非法的 discrimination 歧视 segregation 隔离并区别对待 disorder 障碍 imperative 迫切的 diplomatic 外交的 prevalence 流行 confiscate 没收 marvelous 了不起的 periodical 期刊 sinister 阴险的，凶兆的 qualitative 性质上的，定性的 dormancy 休眠，蛰伏 facilitate 使遍历，减轻…的困难 investment 投资 investigate 调查 narrator 叙述者 narrative 叙事详尽的 slump 下跌，衰落 limp 跛足 catastrophic 灾难性的 inclined 倾向于…的 withstand 经受，承受 overtake 超过，大于 surge 飞涨，激增 reckon 猜想，估计 civil servant 公务员 prospect 希望，前景，景色，勘探，寻找 quote 引述 reconcile 和解 dictation 听写，口述，命令 tropospheric 对流层的 adjacent 邻近的 preclude 阻止 Synonymous en zh-cn working week/professional schedule 工作日程 developed countries/industrialized countries 发达国家 serious problems/severe(critical) issues/major concern 严重问题 advantages and disadvantages/pros and cons 优点和缺点 appear to/seem to 似乎是 Writing Part 2Sentence restructuring origin transformation Unemployment is one of the most serious problems facing developed nations today. It seems increasingly normal for people of industrialized countries to confront umemployment, one of their toughest problems./Lack of jobs is indeed a major concern among many industrialized countries. Some argue that a 35-hour working week is a possible solution to unemployment. What are the advantages and disadvantages of this solution? In this essay, I will outline the pros and cons of lessening professional schedules to thirty five hours. Reference雅思作文,25个万能逻辑链,搞定100个高频题,你能看懂吗？63个高分句式真题练习雅思作文想不出来怎么办Simon全套雅思写作教程 var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"スパークル\",\"author\":\"RADWIMPS\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661491/rm7BsWHz_%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF%E3%83%AB%20%28movie%20ver.%29-RADWIMPS.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661484/aGk0yPw4_18597139672292692.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/20/1/1663661507/S1cBUVM2_%E3%82%B9%E3%83%91%E3%83%BC%E3%82%AF%E3%83%AB%20%28movie%20ver.%29-RADWIMPS.lrc\"}]}; options.element = document.getElementById(\"aplayer-BjAJlcEa\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/19/%E9%9B%85%E6%80%9D%E4%B9%8B%E8%B7%AF/"},{"title":"滑动窗口","text":"参考：滑动窗口 串联所有单词的子串(30)给定一个字符串&nbsp;s&nbsp;和一个字符串数组&nbsp;words。&nbsp;words&nbsp;中所有字符串 长度相同。 s&nbsp;中的 串联子串 是指一个包含&nbsp;&nbsp;words&nbsp;中所有字符串以任意顺序排列连接起来的子串。 例如，如果&nbsp;words = [“ab”,”cd”,”ef”]， 那么&nbsp;“abcdef”，&nbsp;“abefcd”，”cdabef”，&nbsp;“cdefab”，”efabcd”， 和&nbsp;“efcdab” 都是串联子串。&nbsp;“acdbef” 不是串联子串，因为他不是任何&nbsp;words&nbsp;排列的连接。返回所有串联字串在&nbsp;s&nbsp;中的开始索引。你可以以 任意顺序 返回答案。 123456输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]输出：[0,9]解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。 来源：力扣 哈希表 使用Hash Map记录words中每个单词的出现次数 枚举s中的每个字符作为起点，往后取得长度为m*w的子串sub 使用哈希表current统计sub每个单词的出现次数（每隔w长度作为一个单词） 比较current合map是否相同 第三步中如果发现sub出现了words中没有包含的单词，可以剪枝，使用带标签的continue语句直接回到外层循环进行。 1234567891011121314151617181920212223public List&lt;Integer&gt; findSubstring(String s, String[] words) { int n = s.length(), m = words.length, w = words[0].length(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String word : words) { map.put(word, map.getOrDefault(word, 0) + 1); } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); out: for (int i = 0; i + m * w &lt; n; i++) { Map&lt;String, Integer&gt; current = new HashMap&lt;&gt;(); String sub = s.substring(i, i + m * w); for (int j = 0; j &lt; sub.length(); j += w) { String item = s.substring(i, i + w); if (!map.containsKey(item)) continue out; current.put(item, current.getOrDefault(item, 0) + 1); } if (map.equals(current)) { res.add(i); } } return res;} 滑动窗口+哈希表 可以优化这个枚举起点的过程，可以将起点根据 当前下标与单词长度的取余结果 进行分类，这样我们就不用频繁的建立新的哈希表和进行单词统计。 对于取余结果相同的位置，我们可以运用「滑动窗口」来进行词频统计，复杂度为 O(n)，当处理完所有余数情况时，代表我们枚举完了所有的起点。 1234567891011121314151617181920212223242526272829public List&lt;Integer&gt; findSubstring1(String s, String[] words) { int n = s.length(), m = words.length, w = words[0].length(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String word : words) { map.put(word, map.getOrDefault(word, 0) + 1); } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; w; i++) { Map&lt;String, Integer&gt; temp = new HashMap&lt;&gt;(); for (int j = i; j + w &lt;= n; j += w) { String current = s.substring(j, j + w); temp.put(current, temp.getOrDefault(current, 0) + 1); if (j &gt;= i + (m * w)) { int index = j - m * w; String pre = s.substring(index, index + w); if (temp.get(pre) == 1) temp.remove(pre); else temp.put(pre, temp.get(pre) - 1); if (!temp.getOrDefault(pre, 0).equals(map.getOrDefault(pre, 0))) continue; } if (!temp.getOrDefault(current, 0).equals(map.getOrDefault(current, 0))) continue; if (temp.equals(map)) res.add(j - (m - 1) * w); } } return res;} 作者：AC_OIer var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"linear-gradient(135deg, #59adeb 0%, #42c2b5 52%, #34ce93 100%)\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"Pretender\",\"author\":\"official髭男dism\",\"url\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664076228/P0SLz63z_247240257.mp3\",\"pic\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664076312/Ywy7WCGx_official2.jpg\",\"lrc\":\"https://cdn.fygod.xyz/uploads/2022/09/25/1/1664076237/ZUDuvMgB_Pretender-MusicEnc.lrc\"}]}; options.element = document.getElementById(\"aplayer-SFNfENJI\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2022/09/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"tags":[{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"},{"name":"Insert Sort","slug":"Insert-Sort","link":"/tags/Insert-Sort/"},{"name":"Optimization of Sort","slug":"Optimization-of-Sort","link":"/tags/Optimization-of-Sort/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Hash Map","slug":"Hash-Map","link":"/tags/Hash-Map/"},{"name":"English","slug":"English","link":"/tags/English/"}],"categories":[{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"},{"name":"勤能补拙","slug":"勤能补拙","link":"/categories/%E5%8B%A4%E8%83%BD%E8%A1%A5%E6%8B%99/"},{"name":"笔耕不辍","slug":"笔耕不辍","link":"/categories/%E7%AC%94%E8%80%95%E4%B8%8D%E8%BE%8D/"}]}